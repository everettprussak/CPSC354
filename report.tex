\documentclass{article}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-354 Report}
\author{Everett Prussak  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Consisting of CPSC 354 material
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}

This Report consists of 12 Week of Homework from Computer Science 354, Programming Languages, at Chapman University and a Project based on the programming language Swift. In Programming Languages we learned about Abstract and Concrete Syntax Trees, Denotational Semantics, Interpreters, Domain-Specific Languages, and more.

\section{Homework}

\subsection{Week 1}

Homework 1: Using Euclid's Elements Proposition 2 Algorithm on finding the Greatest Common Divisor amongst two numbers.

\subsubsection{Python}
In python, this algorithm can be written as:
\begin{verbatim}
		a = 9
		b = 33

		while(a!=b):
   			if(a>b):
        				a = a-b
    			else:
        				b = b-a
    
		print(a)
\end{verbatim}

Using the sample given, 9 and 33, the Greatest Common Divisor is found in a simple way. Using the Euclid's Elements Proposition 2 Algorithm, we have two variables: \textbf{a} and \textbf{b}. To start, our samples are manually entered from the start of the program, and will begin the while loop. The while loop will continue until the \textbf{a} is the same value as \textbf{b}. The first line of code in the loop is an \textbf{if-statement}. This will compare \textbf{a} and \textbf{b} values, and will continue inside the \textbf{if-statement} if \textbf{a} is a large value than \textbf{b}. The Euclid's Elements Algorithm says: If \[a > b\] then replace \textbf{a} by \[a - b\]This is what happens in this first \textbf{if-statement}, as the variable \textbf{a} is replaced with a - b \medskip\noindent
\medskip\noindent

\noindent If the \textbf{if-statement} is not executed, then the else statement will be preformed. Since our while loop tells us that it will continue until \textbf{a} is the same value as \textbf{b}, then we know that this else statement is: \[b > a\]This is the second part of the Euclid's Elements Proposition 2 Algorithm. It says that when: \[b > a\] to replace \textbf{b} with \[b - a\]This is what happens in this line of python code. The variable \textbf{b} is clearly replaced with b - a. \medskip\noindent

\noindent This while loop will continue until the values of \textbf{a} and \textbf{b} are the same. Once they are, the program will print the value of \textbf{a}. In this particular example, the value \textbf{3} would be printed.

\subsubsection{C++}
In C++, the algorithm can be written as:
\begin{verbatim}
#include <iostream>

using namespace std;

int main(int charc, char** argv){
    int a = 9;
    int b = 33;

    while(a!=b){
        if(a>b){
            a = a-b;
        }
        else{
            b = b-a;
        }
    }
    cout << a << endl;
}
\end{verbatim}
Very similar code to the code in 2.1.1. The same process is being used, with two variables being created before the while loop. The while loop will continue until the values of the two variables are the same. Then the two conditions of \[a > b\] and \[b > a\], are evaluated using an \textbf{if-statement} and \textbf{else-statement}. Once the correct condition is identified, the corresponding calculation done of each variable takes place. This will continue until the Greatest Common Divisor is found, and is printed to the screen. In this place, 3 is again printed.

\subsection{Week 2}

Homework 2: Create six Functions using Haskell: Select Evens, Select Odds, Member, Append, Revert, and Less Equal.

\subsubsection{Select Evens and Select Odds}

The task of these two functions could be used with each other. For Select Evens, the user would write the function name, then a list. The output would be the even element indices (Starting with 1 not 0). Here is the code for both.

\begin{verbatim}

select_evens [] = []
select_evens (x:xs) = select_odds xs

select_odds (x:xs) = x : select_evens xs
select_odds [] = []
\end{verbatim}

\noindent These two functions are connected. Without one, the other will not work.
\newline
\newline Going through the program, we will start with Select Odds. Using recursion, the head element will be split off first. Select Evens will be called with the other elements left in the list. Select Evens will then split the head and other elements again. This process will continue until the tail is an empty list. These methods will allow for only the odd indexed elements to be printed, or only the even indexed elements. 
\newline
\newline Here are a few outputs from the terminal:
\begin{verbatim}
ghci> select_evens ["a","b","c","d","e"]
["b","d"]
ghci> select_odds ["a","b","c"]
["a","c"]
ghci> select_odds ["a","b","c","d","e"]
["a","c","e"]
ghci> select_odds [1,2,3,4,5]
[1,3,5]
ghci> select_evens[432,34,543,2334,23]
[34,2334]
\end{verbatim}
\noindent\newline\newline Here is the Task 2 Equational Reasoning for the Select Evens and Odds Function:

\begin{verbatim}
select_evens ["a","b","c","d","e"] = 

select_evens ("a" : ["b","c","d","e"]]) = select_odds ["b","c","d","e"]

select_odds ("b" : ["c","d","e"]) = "b" : select_evens["c", "d", "e"]

select_evens ("c" : ["d", "e"]) = select_odds["d", "e"]

select_odds ("d" : ["e"]) = "b" : ("d" : select_evens ["e"])

select_evens ("e" : []) = select_odds []

select_odds [] =  "b" : ("d" : ([]))

["b", "d"]
\end{verbatim}

\noindent\newline Note that if Select Odds was called, the same procedure would occur, but would start with Select Odds first and would be the opposite of this output.
\subsubsection{Member}
In the member function, the user would ask for a "True" or "False" about if a list consisted of a particular element. If the list consisted of the element, then True would be returned. Otherwise, False is returned.

\begin{verbatim}
member y (x:xs) = if y==x
    then True
    else if len(xs) < 1
        then False
        else member y xs
\end{verbatim}
The element that the user wants to know is the y. It starts off by comparing y to x, which is the head of the current list. If y is the same as x, then the element that the user is looking for is indeed in the list and True is returned. However, if it is not, then we will use the len function to see the size of the rest of the list. If it is not above 1, then False is returned. False is returned because there is nothing left to compare to the user element. However if it is above 1, then member is called again with the user element and the rest of the elements. This simulates the element being compared to each element in the list. \newline
\newline Here are some outputs for this function:
\begin{verbatim}
ghci> member "a" ["a", "b"]
True
ghci> member "a" ["c", "d", "e"]
False
ghci> member 4 [2,3,5]
False
ghci> member 4 [2,3,3,4,5]
True
ghci> member 4 [4,1,6,2]
True
\end{verbatim}
\noindent\newline\newline Here is the Task 2 Equational Reasoning for the Member Function:
\begin{verbatim}
member 4 [2,3,4] =
    4 == 2
    else if len([3,4]) < 1

    len[3,4] = 3

    else if 3 < 1
        then False
        else member 4 [3,4]
    
member 4 [3,4]  
    4 == 3
    else if len([4]) < 1

    len[4] = 2

    else if 2 < 1
        then False
        else member 4 [4]
    
member 4 [4]
    4 == 4
    then True
\end{verbatim}

\subsubsection{Append}
The append function takes two lists from the user, and appends all of the second lists elements to the back of the first list. This function was difficult for me at first, but I realized that the first list stays at the front of the list, and that only the second list needed elements to "move". \newline
\newline Below is my code for the Append Function:
\begin{verbatim}
append [] (y:ys) = if len(ys) > 0
    then 
        y : append [] ys
    else
        [y] 
append (x:xs) (y:ys) = x : append xs (y:ys)
\end{verbatim}
The last line will be the first line that executes. The user will have the two lists, but the function will have to iterate the entire (x:xs) list first. This is because these elements will be in the front of the new list regardless. After this line is recursively called, the first line will be called with an empty list and all of the second list. The len function is also used in this function as well. The if statement looks at the size of the tail elements of the second list. If it is greater than 0, then it will recursively add the elements to the list that already contains the first list elements. Once the len(ys) is not greater than 0, the else statement will have [y] which will basically not recall any of the append functions, and will not append anything to the list. This will let the recursion end. \newline\newline

 \noindent Here are some outputs of the append function:\newline
\begin{verbatim}
ghci> append [1,2] [3,4,5]
[1,2,3,4,5]
ghci> append [1,2,3,4,5] [7,8,9]
[1,2,3,4,5,7,8,9]
\end{verbatim}

\noindent\newline\newline Here is the Task 2 Equational Reasoning for the Append Function:
\begin{verbatim}
append [1,2,3] [7,8,9] =
    1 : (append [2,3] [7,8,9])
    1 : (2 : (append [3] [7,8,9]))
    1 : (2 : (3 : (append [] [7,8,9])))
    1 : (2 : (3 : (7 : (append [8,9]))))
    1 : (2 : (3 : (7 : (8 : (append [9])))))
    1 : (2 : (3 : (7 : (8 : (9 : (append[]))))))
    1 : (2 : (3 : (7 : (8 : (9 : []))))
\end{verbatim}

\subsubsection{Revert}
The Revert function will take a list from the user, and output the list with the elements in reversed order. \newline
\newline Below is the code to the Revert Function:
\begin{verbatim}
revert [] = []
revert (x:xs) = append (revert xs) [x]
\end{verbatim}
This function uses the previously created function Append. Revert will call the append method recursively. It will append the first element of the list to the back, then continue with the rest of the elements. This was designed with some thought of a Stack. 
\newline Here are some outputs for the Revert Function:
\begin{verbatim}
ghci> revert [1,2,3]
[3,2,1]
ghci> revert [8,1,2,4]
[4,2,1,8]
\end{verbatim}

\noindent\newline\newline Here is the Task 2 Equational Reasoning for the Revert Function:
\begin{verbatim}
revert [1,2,3] = 
    append (revert [2,3]) [1]
    append (append (revert([3]) [2])) [1]
    append (append (append (revert []) [3]) [2]) [1]
    append (append (append [] [3]) [2]) [1]
    append (append [3] [2]) [1]
    append [3,2] [1]
    [3,2,1]
\end{verbatim}

\subsubsection{Less Equal}
The last function that I created was Less Equal. This simply compared the elements from two lists to see if first list was less than or equal to the same indexed element of the other list. For example [1,2] vs [5,6] would be true because 1 is less than or equal to 5 and 2 is less than or equal to 6.\newline
\newline Below is the code to the Less equal Function
\begin{verbatim}
less_equal [] [] = True
less_equal (x:xs) (y:ys) = if x<=y
    then 
        less_equal xs ys
    else
        False
\end{verbatim}
The beginning of this function will start with the second line. If compares the head elements of list 1 and list 2. If x is less than or equal to, the Less Equal function will be called again, but this time with the tail elements. If at any point the list 1 element "x" is greater than list 2 element "y", False will be returned. If all of the elements are compared, then base case is called. This is because there are no elements left, so they are empty lists. Since nothing was flagged, then True will be returned, meaning that all of the list 1 elements are either less than or equal to the list 2 elements at the same index.\newline
\newline Here are some outputs for the Less Equal Function:
\begin{verbatim}
ghci> less_equal [1,2,3] [2,3,4]
True
ghci> less_equal [1,2,3] [2,3,2]
False
ghci> less_equal [1,2,3] [2,3,3]
True
\end{verbatim}
\noindent\newline\newline Here is the Task 2 Equational Reasoning for the Less Equal Function:
\begin{verbatim}
less_equal [1,2,3] [2,3,4] =
    1 <= 2
    then
        less_equal [2,3] [3,4]

    2 <= 3
    then
        less_equal [3] [4]
    
    3 <= 4
    then
        less_equal [] []
    
    True
\end{verbatim}
\noindent\newline If the left value was ever larger, than False would be the value.
\subsubsection{Len}
I did not create this function. I took this from \href{https://hackmd.io/@alexhkurz/H1jUka4Gv#fn2}{Hackmd.io}, thanks to Professor Kurz. Below is the code used that my other functions also used.
\begin{verbatim}
len [] = 0
len (x:xs) = 1 + len xs
\end{verbatim}

\subsection{Week 3}
Week 3 Homework was about the Hanoi Tower. The task was to complete the execution from the dots down. Here that is:
\begin{verbatim}
hanoi 5 0 2  
	hanoi 4 0 1 
		hanoi 3 0 2
			hanoi 2 0 1 
				hanoi 1 0 2 = move 0 2 
				move  0 1
				hanoi 1 2 1 = move 2 1 
			move 0 2  
			hanoi 2 1 2  
				hanoi 1 1 0 = move 1 0  
				move  1 2  
				hanoi 1 0 2 = move 0 2
        move 0 1
        hanoi 3 2 1
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
            move 2 1
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
    move 0 2
    hanoi 4 1 2
        hanoi 3 1 0
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
            move 1 0
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
        move 1 2
        hanoi 3 0 2
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
            move 0 2 
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
\end{verbatim}
I followed this exact sequence with the \href{https://www.mathsisfun.com/games/towerofhanoi.html}{Tower of Hanoi} website. It took 31 turns, which is the minimum moves possible for a Hanoi Tower of size 5. \newline

\noindent The word "Hanoi" appears 31 times. The word "move" also appears 31 times. \newline
\noindent A simple equation can be expressed for the number of blocks in the Hanoi Tower. Assuming n is the number of blocks/rings in the tower, the minimum number of moves can be expressed as $$2^n - 1$$ In this case, n was 5. Thus, $$2^5 = 32$$ and then $$32 - 1 = 31$$ Here are some other minimum moves required for other ring heights. $$2^1 - 1 = 1$$ $$2^2 - 1 = 3$$ $$2^3 - 1 = 7$$ $$2^4 - 1 = 15$$ $$2^6 - 1 = 63$$

\subsection{Week 4} Week 4 consisted of making Parse Tree and Abstract Syntax Tree of math 5 problems. 
\subsubsection{Parse Tree Diagrams}
This is Part 1 of Week 4's Homework. The task was to write out the derivation trees for the following:

$$2+1$$
$$1+2*3$$
$$1+(2*3)$$
$$(1+2)*3$$
$$1+2*3+4*5+6$$

\noindent\newline while using this Context-Free Grammar:

\begin{verbatim}
Exp -> Exp '+' Exp1 
Exp1 -> Exp1 '*' Exp2              
Exp2 -> Integer            
Exp2 -> '(' Exp ')'  
Exp -> Exp1             
Exp1 -> Exp2                                     
\end{verbatim}


\noindent\newline For $$2+1$$ I got the following Parse Tree:

\begin{verbatim}
         Exp
       /  |  \
      Exp '+' Exp1
     /         \
    Exp1        Exp2
   /             \
  Exp2           Integer
 /                 |
Integer            1
  |
  2
\end{verbatim}
\noindent\newline Here this tree starts with Exp. It expands for addition with Exp and Exp1. After this, I simply converted Exp to Exp1 to Exp2 then the number 2, and Exp1 to Exp2 then the number 1.

\noindent\newline\newline For $$1+2*3$$ I got the following Parse Tree:

\begin{verbatim}
         __ Exp__
        /    |   \
      Exp   '+'   __Exp1__
      /          /    |    \
    Exp1       Exp1  '*'   Exp2
    /           |          |
   Exp2        Exp2      Integer
    |           |           |
 Integer      Integer       3
    |           |
    1           2
    \end{verbatim}
\noindent\newline This Tree starts similar to last time with Exp. Exp will expand to Exp and Exp1. Exp will expand directly until it is the integer 1. Exp1 will expand to Exp1 and Exp2 for multiplication. Exp1 and Exp2 from this will become 2 and 3. This will allow the tree to calculate 2 times 3 to become 6. Then the root will have the two nodes of 1 and 6 to add to become 7.


\noindent\newline\newline For $$1+(2*3)$$ I got the following Parse Tree:
\begin{verbatim}
        ___Exp____
       /    |      \
     Exp   '+'    Exp1
    /               |
   Exp1            Exp2
   |             /  |  \
   Exp2        '(' Exp ')'
   |                |
 Integer           Exp1
   |              /    \
   1           Exp1   Exp2
                |       |
               Exp2   Integer
                |        |
              Integer    3
                |
                2

\end{verbatim}
\noindent\newline This is a little more complex than the prior example, but will end with the same answer of 7. Exp will expand to Exp and Exp1 for addition. Exp will expand until it becomes the integer of 1. Exp1 will become Exp2 then Exp because this had parenthesis. Exp will expand to Exp1, then Exp1 will expand to Exp1 and Exp2. These will become 2 and 3 so it will be multiplied together. Then this will finally become 7 if calculated.


\noindent\newline\newline For $$(1+2)*3$$ I got the following Parse Tree:
\begin{verbatim}
        ____Exp1___
       /     |     \
     Exp1   '*'     Exp2
    /            /  |   \
   Exp2        '('  Exp ')'
  /               /  |  \
Integer         Exp '+'  Exp1
  |             |         |
  3            Exp1      Exp2
                |         |
              Exp2      Integer
                |         |
             Interger     2
                |
                1

\end{verbatim}
\noindent\newline This time the parenthesis is with the addition of 1 and 2. I started with multiplication (Exp1) because it is 3 being multiplied with the entire parenthesis. Exp1 will expand to Exp1 and Exp2. Exp1 will become the integer 3. Exp2 will first go back to Exp because this is a parenthesis and our rule allows to go back to Exp when Parenthesis is present. Exp will then expand to Exp and Exp1 for the addition. These will expand until the integers 1 and 2 are present. Then 1 added to 2 will become 3. 3 multiple with 3 will become 9. This answer is 9.

\noindent\newline\newline For $$1+2*3+4*5+6$$ I got the following Parse Tree:
\begin{verbatim}
                ____________Exp__________
               /             |            \
            _____Exp_____   '+'          Exp1
          /       |      \                  \
          Exp    '+'       Exp1            Exp2
       /   |  \          /   |   \          |
      Exp '+' Exp1     Exp1 '*'  Exp2     Integer
     /      /   |  \    |            |     |
    Exp1  Exp1 '* Exp2  Exp2      Integer  6
     |      |      |      |          |
    Exp2   Exp2 Integer  Integer     5
     |      |       \     |
    Integer Integer  3    4
    |       |
    1       2
\end{verbatim}
\noindent\newline This was by far the most complicated of the problems. To start, I expanded with the addition of 1 with everything else. This means Exp would be the root with Exp and Exp1 being the child nodes. Exp1 will become Exp2 then the integer 1. Now I must account for the other 5 numbers in the equation. Starting with Exp again I decided for the sum of 2 multiple with 3 being added to entire sum of 4 multiplied with 5 and then added with 1. Exp will expand to Exp and Exp1 for this addition. Exp1 will become the 2 times 3 side of the equation. Exp1 will expand to Exp1 and Exp2. Exp1 will expand until integer 2 is reached, and Exp2 is expanded until integer 3 is reached. Now back to the Exp that is being added with 2 times 3. This Exp will be expanded to Exp and Exp1. Exp will be expanded until integer 6 is reached. Exp1 is the multiplication formula. Exp1 will expand to Exp1 and Exp2. These two nodes will then be converted until integer 4 and 5 are reached. Now the tree is complete. First 1 will be added with the rest of the equation. The rest of the equation will have 2 multiplied with 3 become 6. 4 is multipled by 5 to become 20 then added with 6 to become 26. This 26 is added with 6 from 2 times 3. Then our 1 is added to become 33.

\subsubsection{Abstract Syntax Tree} The same 5 problems (Equations) that were used for the Parse Tree's are now used to be made into Abstract Syntax Trees.

\noindent\newline\newline These AST are to be made using this BNFC Grammar:
\begin{verbatim}
Plus.   Exp ::= Exp "+" Exp1 ;
Times.  Exp1 ::= Exp1 "*" Exp2 ;
Num.    Exp2 ::= Integer ;

coercions Exp 2 ;
\end{verbatim}

\noindent\newline For $$2+1$$ I got the following Abstract Syntax Tree:
\begin{verbatim}
        Plus
        /  \
       Num  Num
       |     |
       2     1
\end{verbatim}

\noindent\newline This Abstract Syntax Tree is easy to read. The only math being used is an addition sign. Simply Plus is used then expanded to its two terms of 2 and 1.


\noindent\newline\newline For $$1+2*3$$ I got the following Abstract Syntax Tree:
\begin{verbatim}
         Plus
        /    \
       Num   Times
        |   /   \
        1  Num  Num
            |    |
            2    3
\end{verbatim}
\noindent\newline This Abstract Syntax Tree is bigger than the prior equation/problem. I once again started with Plus then expanded 1 and the product of 2 times 3. This works with our Grammar Rules. 

\noindent\newline\newline For $$1+(2*3)$$ I got the following Abstract Syntax Tree:
\begin{verbatim}
         Plus
        /    \
       Num   Times
        |   /   \
        1  Num  Num
            |    |
            2    3
\end{verbatim}
\noindent\newline This is the same exact AST as the prior example. Since the parenthesis is around the multiplication, which would be first in this instance anyways, nothing changes. Other than the parenthesis being added, nothing changes, so the rest of the AST is the same

\noindent\newline\newline For $$(1+2)*3$$ I got the following Abstract Syntax Tree:

\begin{verbatim}
        Times
        /   \
       Plus  Num
       /  \    |
      Num Num  3
      |    |
      1    2
\end{verbatim}
\noindent\newline This AST is different than the prior examples. Since the parenthesis are around the 1 plus 2, then this part must be done first in order to be multiplied with the three. I had Times be the root with the expansion of integer 3, and Plus. The Plus would then expand to 1 and 2. By this tree, 1 Plus 2 is 3 then 3 times 3 is 9. 

\noindent\newline\newline For $$1+2*3+4*5+6$$ I got the following Abstract Syntax Tree:

\begin{verbatim}
          ______Plus______
        /                  \
       __Plus__            Num
     /         \             |
    Plus       Times         6
   /   \       /   \
  Num  Times Num   Num
   |   /  \   |     |
   1  Num Num 4     5
      |    |
      2    3
\end{verbatim}
\noindent\newline This AST is much more complex than the other examples. To begin, I had Plus become the root, as 1 Plus other side of equation will be the child nodes. The nodes will be integer 1 and Plus. Plus will expand to Plus and Times. The Times will expand to the first part of the other equation of 2 Times 3. The Plus will expand to Times and integer 6. The Times will become 4 and 5. Doing this AST from bottom up, will have 4 Times 5 become 20. Then 20 Plus 6 becoming 26. 2 Times 3 becoming 6. 6 plus 26 becoming 32. Then finally 32 will be added with 1 to have 33 as the grand total, the same as the Parse Tree example.

\noindent\newline\newline
\textbf{Is the abstract syntax tree of 1+2+3 identical to the one of (1+2)+3 or the one of 1+(2+3)?}

\noindent Yes, the AST are the same for these three equations.

\subsection{Week 5} For this week's homework, the task was to create Abstract Syntax Trees and evaluate lambda expressions.

\subsubsection{Abstract Syntax Trees of Lambda Calculus}
The following expressions were given to create 2-D Abstract Syntax Trees and Linearized Abstract Syntax Trees.
\begin{verbatim}
x
x x
x y
x y z
\ x.x
\ x.x x
(\ x . (\ y . x y)) (\ x.x) z
(\ x . \ y . x y z) a b c
\end{verbatim}
\noindent\newline Here is the Linearized and 2-D AST for x:
\begin{verbatim}
EVar(Ident "x")

        EVar
         |
         x
\end{verbatim}
\noindent\newline Here is the Linearized and 2-D AST for x x:
\begin{verbatim}
EApp(EVar(Ident "x") EVar(Ident "x"))
         EApp
        /    \
       EVar  EVar
        |     |
        x     x 
\end{verbatim}
\noindent\newline Here is the Linearized and 2-D AST for x y:
\begin{verbatim}
EApp(EVar(Ident "x") EVar(Ident "y"))
        EApp
       /    \
      EVar  EVar
       |     |
       x     y
\end{verbatim}
\noindent\newline Here is the Linearized and 2-D AST for x y z:
\begin{verbatim}
EApp (EApp (EVar (Ident "x")) (EVar (Ident "y"))) (EVar (Ident "z"))
       EApp
      /    \
    EVar   EApp
     |    /    \
     z   EVar  EVar
          |     |
          y     x
\end{verbatim}
\noindent\newline Here is the Linearized and 2-D AST for $$\backslash x. x$$
\begin{verbatim}
EAbs (Ident "x") (EVar (Ident "x"))
            EAbs
          /     \
         x      EVar
                 |
                 x
\end{verbatim}
\noindent\newline Here is the Linearized and 2-D AST for $$\backslash x. x x$$
\begin{verbatim}
EAbs (Ident "x") (EApp (EVar (Ident "x")) (EVar (Ident "x")))
             EAbs
           /     \
        EApp     EVar
        /   \      |
    EVar    EVar   x
      |       |
      x       x
\end{verbatim}
\noindent\newline Here is the Linearized and 2-D AST for $$(\backslash x. (\backslash y . x y)) (\backslash x.x) z$$
\begin{verbatim}
EApp (EApp (EAbs (Ident "x") (EAbs (Ident "y") (EApp (EVar (Ident "x")) (EVar (Ident "y"))))) 
(EAbs (Ident "x") (EVar (Ident "x")))) (EVar (Ident "z"))


           EApp
        /        \
       EApp       EVar
    /      \        |
  EAbs      EAbs    z
  /  \      /  \
 x   EAbs   x   EVar
     /  \        |
    y   EApp     x
       /    \
      EVar  EVar
       |     |
       x     y
\end{verbatim}
\noindent\newline Here is the Linearized and 2-D AST for $$(\backslash x . \backslash y . x y z) a b c$$
\begin{verbatim}
EApp (EApp (EApp (EAbs (Ident "x") (EAbs (Ident "y") (EApp (EApp (EVar (Ident "x")) 
(EVar (Ident "y"))) (EVar (Ident "z"))))) (EVar (Ident "a"))) (EVar (Ident "b"))) (EVar (Ident "c"))

                  ________EApp________
                /                      \
              EApp                     EVar
            /     \                      |
          EApp    EVar                   c
        /     \    |
      EAbs   EVar  b
     /   \      \  
    x    EAbs    a
        /    \
       y     EApp 
            /    \
          EApp   EVar 
         /   \    |
        EVar EVar z
        |     |
        x     y
\end{verbatim}
\noindent\newline\newline These expressions start easy with simple free variables such as x. The problems gradually got harder to include bound variables, and would need to be changed if we were evaluating these expressions.

\subsubsection{Lambda Expression Evaluation}
This section is to evaluate the following Lambda Expressions and solve:
\begin{verbatim}
 1.  (\x.x) a         
 2.  \x.x a           
 3. (\x.\y.x) a b    
 4. (\x.\y.y) a b    
 5. (\x.\y.x) a b c  
 6. (\x.\y.y) a b c  
 7. (\x.\y.x) a (b c)
 8. (\x.\y.y) a (b c)
 9. (\x.\y.x) (a b) c
 10. (\x.\y.y) (a b) c
 11. (\x.\y.x) (a b c)
 12. (\x.\y.y) (a b c)
\end{verbatim}

Here is the evaluation for number 1:
\begin{verbatim}
  (\x.x) a = a 
\end{verbatim}  

Here is the evaluation for number 2:
\begin{verbatim}
  \x.x a = a   
\end{verbatim}  

Here is the evaluation for number 3:
\begin{verbatim}
  (\x.\y.x) a b 
  (\y.a) b = a
\end{verbatim}  

Here is the evaluation for number 4:
\begin{verbatim}
  (\x.\y.y) a b   
  (\y.y) b = b
\end{verbatim}  

Here is the evaluation for number 5:
\begin{verbatim}
  (\x.\y.x) a b c  
  (\y.a) b c
  (\y.a) c = a c
\end{verbatim}  

Here is the evaluation for number 6:
\begin{verbatim}
  (\x.\y.y) a b c
  (\y.y) b c
  (\y.b) c = b c
\end{verbatim}  

Here is the evaluation for number 7:
\begin{verbatim}
  (\x.\y.x) a (b c)
  (\y.a) (b c) = a
\end{verbatim}  

Here is the evaluation for number 8:
\begin{verbatim}
  (\x.\y.y) a (b c)
  (\y.y) (b c) = b c 
\end{verbatim}  

Here is the evaluation for number 9:
\begin{verbatim}
  (\x.\y.x) (a b) c
  (\y.a b) c = a b
\end{verbatim}  

Here is the evaluation for number 10:
\begin{verbatim}
  (\x.\y.y) (a b) c
  (\y.y) c = c 
\end{verbatim}  

Here is the evaluation for number 11:
\begin{verbatim}
  (\x.\y.x) (a b c)
  (\y.a b c) = a b c
\end{verbatim}  

Here is the evaluation for number 12:
\begin{verbatim}
  (\x.\y.y) (a b c)
  (\y.y) = \y.y
\end{verbatim}  

\subsubsection{evalCBN calculation}
The task her was to write by hand the calculation of 
\begin{verbatim}
(\x.x)((\y.y)a)
\end{verbatim}

using evalCBN in interpreter.hs.

Clearly the answer here would simply be "a", but in terms of what the computer sees will be different

\begin{verbatim}
evalCBN (EApp (EAbs (Ident "x") (EVar (Ident "x"))) (EApp (EAbs (Ident "y") 
(EVar (Ident "y"))) (EVar (Ident "a")))) =  -- Parser

evalCBN (subst (Ident "x") (EApp (EAbs (Ident "y") (EVar (Ident "y"))) 
(EVar (Ident "a"))) EVar (Ident "x")) =  -- Line 27

evalCBN (EApp (EAbs (Ident "y") (EVar (Ident "y"))) (EVar (Ident "a"))) =  -- Line 47

evalCBN (subst (Ident "y") (EVar (Ident "a")) (EVar (Ident "x"))) =  -- Line 27

evalCBN (EVar (Ident "a")) =  -- Line 47

EVar (Ident "a") =  -- Line 32
\end{verbatim}


\subsection{Week 6}
\subsubsection{Evaluation}
The goal this week was to Evaluate \begin{verbatim}
(\exp . \two . \three . exp two three)
(\m.\n. m n)
(\f.\x. f (f x))
(\f.\x. f (f (f x)))
\end{verbatim}

\noindent\newline\newline Here is what I got:

\begin{verbatim}
(\exp . \two . \three . exp two three)
(\m.\n. m n)
(\f.\x. f (f x))
(\f.\x. f (f (f x)))
=
((\m.\n. m n) (\f.\x. f (f x)) (\f2.\x2. f2 (f2 (f2 x2))))
=
((\n. (\f.\x. f (f x)) n) (\f2.\x2. f2 (f2 (f2 x2))))
=
(((\f.\x. f (f x)) (\f2.\x2. f2 (f2 (f2 x2)))))
=
(((\x. (\f2.\x2. f2 (f2 (f2 x2))) ((\f2.\x2. f2 (f2 (f2 x2))) x))))
=
(((\x. (\x2. ((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) 
(((\f2.\x2. f2 (f2 (f2 x2))) x) x2))))))
=
(((\x. ((\x2. x (x (x (((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2))))))))))
=
(((\x. ((\x2. x (x (x (((\x2. x (x (x x2)))) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2))))))))))
=
(((\x. ((\x2. x (x (x (((x (x (x (((\f2.\x2. f2 (f2 (f2 x2))) x) x2))))))))))))))
=
(((\x. ((\x2. x (x (x (((x (x (x (((\x2. x (x (x x2)))) x2))))))))))))))
=
(((\x. ((\x2. x (x (x (((x (x (x (((x (x (x x2))))))))))))))))))
\end{verbatim}

\subsection{Week 7}
For week 7, there were a variety of tasks. The first was to draw a picture for a number of ARSs. Next was to find an example of an ARS for specific cases. Another task was to the variable for certain lines. evalCBN for hw5 if not done, but in my case is done in Week 5 section. Lastly to use evalCBN for another lambda term.

\subsubsection{ARS Picture/Determination}

The task in this section was to \begin{verbatim}
Consider the following list of ARSs.
1. A = {}
2. A = {a} and R = {}
3. A= {a} and R = {(a,a)}
4. A = {a,b,c} and R = {(a,b),(a,c)}
5. A = {a,b} and R = {(a,a),(a,b)}
6. A = {a,b,c} and R = {(a,b),(b,b),(a,c)}
7. A = {a,b,c} and R = {(a,b),(b,b),(a,c),(c,c)}

Draw a picture for each of the ARSs.

Is the ARS terminating? Is it confluent? Does it have unique normal forms?
\end{verbatim}

\noindent Picture 1:
\includegraphics{image1}
\noindent\newline It is terminating, it is confluent, and it has a unique normal form.

\noindent\newline\newline Picture 2:
\includegraphics{image2}
\noindent\newline It is terminating, it is confluent, and it has a unique normal form.

\noindent\newline\newline Picture 3:
\includegraphics{image3}
\noindent\newline It is not terminating, it is confluent, and it does not have unique normal forms.

\noindent\newline\newline Picture 4:
\includegraphics{image4}
\noindent\newline It is terminating, it is not confluent, and it does not have unique normal forms.

\noindent\newline\newline Picture 5:
\includegraphics{image5}\noindent\newline It is not terminating, it is confluent, and it does have unique normal forms. b is the UNF of a.


\noindent\newline\newline Picture 6:
\includegraphics{image6}\noindent\newline It is not terminating, it is not confluent, and it does not have unique normal forms.


\noindent\newline\newline Picture 7:
\includegraphics{image7}\noindent\newline It is not terminating, it is not confluent, and it does not have unique normal forms.


\subsubsection{ARS examples}
In this section of the homework, the task was to try find an example of an ARS for specific combinations, and to draw the picture of that example. 

Here are the combinations that are being tested:

\includegraphics[scale=0.5]{combinations}

\hrulefill

\noindent\newline For number 1, confluent = True, terminating = True, and Unique Normal Form = True, I got the following ARS:

\includegraphics{part2}

\noindent\newline Here, confluence, terminating, and Unique Normal Form are all true. The a is the peak, and b and c reduce into d which is the valley. There is no possibility of having an infinite loop. Lastly, d is the UNF.

\hrulefill

\noindent\newline\newline For number 2, confluent = True, terminating = True, and Unique Normal Form = False, I got the following ARS:


\noindent\newline There is not an example for this situation. When Confluence and Terminating are True, that means that UNF must be true. There will not be any situation or diagram where this is not true.

\hrulefill

\noindent\newline\newline For number 3, confluent = True, terminating = False, and Unique Normal Form = True, I got the following ARS:

\includegraphics{part4}

\noindent\newline Similar to my example in number 1, Confluence is true due to the peak existing with a valley. d would be the UNF in this case. Lastly, it is not terminating because of the possibility of an endless loop on a.

\hrulefill

\noindent\newline\newline For number 4, confluent = True, terminating = False, and Unique Normal Form = False, I got the following ARS:

\includegraphics{part4_corrent}

\noindent\newline Here confluence is true due to the peak and valley being present. Terminating would be false because of the possibility of having an endless loop. Lastly a,b,c, and d all have a possibility of an endless loop, which means that none of them are normal forms, meaning no UNF could be possible.

\hrulefill

\noindent\newline\newline For number 5, confluent = False, terminating = True, and Unique Normal Form = True, I got the following ARS:

\noindent\newline There is no scenario that exists for this situation. When Confluence is false, UNF will never be true. 

\hrulefill

\noindent\newline\newline For number 6, confluent = False, terminating = True, and Unique Normal Form = False, I got the following ARS:

\includegraphics{part6}

\noindent\newline Again, a is the peak, but there is no valley. This means that confluent is false for this ARS. This is terminating because a, b, and c, do not have opportunity to be part of an endless loop anywhere. This ARS would simply start at a then go to b or c. This ARS does not have a UNF because b and c are both normal forms, but a must only have one normal form to have a UNF. 

\hrulefill

\noindent\newline\newline For number 7, confluent = False, terminating = False, and Unique Normal Form = True, I got the following ARS:


\noindent\newline There is not an example for this scenario. When confluence is false, UNF will always never be True.

\hrulefill

\noindent\newline\newline For number 8, confluent = False, terminating = False, and Unique Normal Form = False, I got the following ARS:

\includegraphics{part8}

\noindent\newline Similar to number 7, but instead of just b from a, there is b and c. That means that both are normal forms, but a must only have one normal form to have an unique normal form. In this case, all 3 are False.

\hrulefill

\subsubsection{Bound and Free Variables}
In this section of Week 7, the task was to 
\begin{verbatim}
in lines 5-7 and also in lines 18-22 explain for each variable

- whether it is bound or free
- if it is bound say what  the binder and the scope of the variable are
\end{verbatim}

\noindent\newline Here are lines 5-7 that are referred to: 
\begin{verbatim}
evalCBN (EApp e1 e2) = case (evalCBN e1) of
    (EAbs i e3) -> evalCBN (subst i e2 e3)
    e3 -> EApp e3 e2
\end{verbatim}

\noindent\newline The variables e1 and e2 are both bound variables. Their scope goes from the line 5 to line 7. The reason they are bound variables is because the rest of the this function uses e1 and e2 because of there instance in \begin{verbatim} evalCBN (EApp e1 e2) \end{verbatim}

\noindent which tells us that the other lines are bound by the occurrence of e1 and e2.
\noindent\newline\newline The binder of the variables e1 and e2 is
\begin{verbatim}
(EApp e3 e2)
\end{verbatim}

\noindent\newline\newline The variable i and e3 (on line 6) is a bound variable. The scope is just the line it is on, which is line 6, 
\begin{verbatim}
evalCBN (subst i e2 e3)
\end{verbatim}
The binder is 
\begin{verbatim}
(EAbs i e3).
\end{verbatim}

\noindent\newline\newline The second instance of e3, which is different than the one mentioned on line 6, has a scope of 
\begin{verbatim}
EApp e3 e2
\end{verbatim}
and a binder of
\begin{verbatim}
e3
\end{verbatim}


\noindent\newline\newline\newline Here are the lines 18-22 that are referred to:
\begin{verbatim}
subst id s (EAbs id1 e1) =
    let f = fresh (EAbs id1 e1)
        e2 = subst id1 (EVar f) e1 in 
        EAbs f (subst id s e2)
        
\end{verbatim}

\noindent\newline For the variable id, s, id1, and e1, they are all bound variables. The scope would be lines 18-22, and the binder for s would be 
\begin{verbatim} 
id s (EAbs id1 e1)
\end{verbatim}

\noindent\newline The variable f would also be a bound variable. The scope would be from lines 19 to 22. The binder would be 
\begin{verbatim}
let f
\end{verbatim}

\noindent\newline the variable e2 would also be a bound variable. The scope would be from line 20-22. The binder would be 
\begin{verbatim}
e2
\end{verbatim}


\noindent\newline 

\noindent\newline The binder for id1 and e1 would be \begin{verbatim} (EAbs id1 e1) \end{verbatim}

\subsubsection{evalCBN calculation, part 2}

\noindent The task here was to use evalCBN and subst from Interpreter.hs, and solve by hand showing how to computer processes this information and calculations.

\begin{verbatim}
(\x.\y.x) y z
\end{verbatim}

This was the lambda expression given. If calculating here, the answer would simply be the second y, which would have to be substituted.

\begin{verbatim}
evalCBN (EApp (EApp (EAbs (Ident "x") (EAbs (Ident "y") (EVar (Ident "x")))) 
EVar (Ident "y"))) (EVar (Ident "z"))) = From Parser

evalCBN ((EAbs (Ident "x") (EAbs (Ident "y") (EVar (Ident "x")))) (EVar (Ident "z")) 
(EVar (Ident "y"))) = Line 27

evalCBN (EVar (Ident "y")) = Line 48

EVar(Ident "y") = Line 32
\end{verbatim}

\subsection{Week 8}
This week the task was to examine the rewrite rules of
\begin{verbatim}
  aa -> a
  bb -> b
  ba -> ab
  ab -> ba
\end{verbatim}
and to answer the following questions:
\begin{verbatim}
1. Why does the ARS not terminate?
2. What are the normal forms?
3. Can you change the rules so that the new ARS has unique normal forms (but still has 
the same equivalence relation)?
4. What do the normal forms mean? Describe the function implemented by the ARS.
\end{verbatim}
\noindent For \textbf{number 1}, the ARS as currently constructed would \textbf{not terminate} because the rules 
\begin{verbatim}
  ba -> ab
  ab -> ba
\end{verbatim}
\noindent These two rules are doing the opposite of each other. Every time ba transforms into ab, ab will transform back to ba. This will continue to happen, and will be an endless loop, meaning that these rewrite rules are not terminating.

\noindent\newline\newline For \textbf{number 2}, the normal forms would be a, b, and [ ]. Since aa reduces to a, and bb reduces to b, but a and b do not reduce to anything, these would be the normal forms. [ ] is also a normal form

\noindent\newline\newline \textbf{number 3:} Here are the rules I changed so that the new ARS has unique normal forms, and still has the same equivalence relation.

\begin{verbatim}
  aa -> a
  bb -> b
  ba -> ab
\end{verbatim}

\noindent I simply got rid of the last rule. a is the UNF for aa, and b is the UNF for bb. Since the rewriting rules are terminating now, this will allow for UNF to exist. Since we got rid of the last rule, this ARS is not longer an infinite computation, meaning that it is now terminating.

\noindent\newline Now we have four normal forms: a, b, ab, and [ ].

\noindent\newline To prove that this new ARS is terminating, here are multiple examples:

\begin{verbatim}
1. 
aaaabababa
aaabababa
aabababa
abababa
aabbaba
abbaba
ababa
aabba
abba
aba
aab
ab

2.
abbbba
abbba
abba
aba
aab
ab


3.
aaaaa
aaaa
aaa
aa
a

4.
bbbbb
bbbb
bbb
bb
b

5.
aaaaaab
aaaaab
aaaab
aaab
aab
ab

6.


\end{verbatim}

\noindent\newline As you can see here, these examples all reach the 4 normal forms, and will not continue computing. In number 6, we can see the example of the normal form [ ].

\noindent\newline A rule I made was: If there is at least one a and at least one b, then it will reduce to ab. If there is at least one a and no b, then it will reduce to a. If there is at least one b and no a, then it will reduce to b. Lastly, if there is no a and no b, them it will reduce to [ ].

\noindent\newline This brings us to our 4 invariants that can be represented with this table:
\begin{verbatim}
Normal Form:                     Invariant:
[ ]                              no a, no b
a                                at least one a, no b
b                                no a, at least one b
ab                               at least one a, at least one b

\end{verbatim}

\noindent\newline With these invariants, the equivalence relation can be proved that it did not change. First, computationally each equivalence class is characterized by its normal form. This means that each word reduces to the normal form in the ARS, which was proven above. Last, mathematically the equivalence classes can be specified without reference to the computation rules.

\noindent\newline\newline \textbf{number 4:} The normal forms mean that it does not reduce into anything else. We proved with examples and a rule that the each word in the ARS will be reduced to these normal forms.

\subsection{Week 9} In week 9, the task were to describe 3 milestones for the project and analysis of ARSs

\subsubsection{Project Milestones} For the project, there are going to be 3 main milestones that will allow this project to be done smoothly. The first milestone will be to research strengths and weaknesses about the programming language Swift. This should be fully done by November 8th, or earlier if possible. This task will require research that should take a few days, and some time to write about it in the Report section. The next milestone will be to come up with an idea of an App or Game that will show how these strengths and weaknesses affect coding in this language. This should be done November 13th, as this is a brainstorming section. When I decide, I will write about why I choose to do the App/Game, and how it is related to prior sections of the report. Lastly, I will fully build the App/Game to a working prototype by the early December (December 2nd?). I am not sure how long this will take, so I am not sure what exact deadline I should give myself. I want to have some of the App/Game done before thanksgiving break to show its progress, then to be fully done before Finals week. There will be more explaining on specific things I did in my code, how the app/game works, and links to where I have my code.

\subsubsection{ARS Analysis}
The first set of rules were
\begin{verbatim}
ba -> ab
ab -> ba
ac -> ca
ca -> ac
bc -> cb
cb -> bc
 
aa -> b
ab -> c
ac ->  
bb ->
cb -> a
cc -> b
\end{verbatim}
First off, this schema of rules does not terminate. If drawn out, you would see that ba would point to ab, then ab would point back to ba. This would repeat and repeat. This happens for all of these rules, and will be stuck in an infinite loop. The top set of rules would cause issues in many ways.

\noindent\newline Since this an Infinite Computation, then that means the ARS is not terminating, and therefore the currently constructed ARS is not an \textbf{Algorithm}. An ARS is an Algorithm when it is terminating and has unique normal forms. This will be the first step of analysis we must take.

\noindent\newline Here is a rewrite of the ARS to allow for termination and unique normal forms.

\begin{verbatim}
ba -> ab
ca -> ac
cb -> bc
 
aa -> b
bb ->
cc -> b
\end{verbatim}

\noindent\newline Proving Termination:
\noindent\newline We know that are ARS is in the form ARS (A,->). The function 
: A→N is called a measure function if a → b implies (a) > (b)


\noindent\newline This measure function would be true, meaning that termination now exists.

\noindent\newline The unique normal forms we have are:
\begin{verbatim}
[ ]
b
ab
ac
bc
\end{verbatim}
\noindent\newline These are Normal Forms because this ARS has confluence and is terminating. We can also see form our new ARS we wrote that these cannot be reduced down any more.

\noindent Since this ARS now is terminating and has unique normal forms, that means that is is an Algorithm. The last step of analysis is finding specification the ARS implements. This means it must have a complete invariant.

\noindent\newline Here are the invariants I found:
\begin{verbatim}
Invariant                              Normal Form
even #b, no a, no c                    [ ]
no a, no b, no c                       [ ]
even #a, no b, no c                     b
no a, no b, even #c                     b
one a, one b, no c                      ab
one a, no b, one c                      ac
no a, one b, one c                      bc
\end{verbatim}

\noindent\newline Now with our invariants (That are complete), we have fully analyzed the ARS. As you can see the ARS had to have many changes to allow for termination, and normal forms.


  
 \subsection{Week 10}
 The task for Week 10 was to calculate
 \newline
\newline fix$_f$2
 \newline
 \newline These are all the steps I executed: \newline
f 2 = \newline
fix$_f$ 2 =  --def of fix\newline
F fix$_f$ 2  =  --def of F\newline
( $\backslash$ f. $\backslash$ n. if n == 0 then 1 else f(n-1)*n) fix$_f$ 2 =  --def of if then else\newline
(if 2==0 then 1 else fix$_f$ (2-1)*2) fix$_f$ 2 =  -- def of if then else\newline
(fix$_f$ 1) * 2 =  -- def of fix\newline 
(F fix$_f$ 1) * 2  =  -- def of F\newline
(($\backslash$ f. $\backslash$ n. if n == 0 then 1 else f(n-1)*n) fix$_f$ 1) * 2 =  --def of if then else\newline
(($\backslash$ f. $\backslash$ n. if 1 == 0 then 1 else f(1-1) * 1) fix$_f$ 1) * 2 =  -- def of beta reduction\newline
((fix$_f$ 0) * 1) * 2 =  --def of fix\newline
((F fix$_f$ 0) * 1) * 2 =  --def of F\newline
(($\backslash$ f. $\backslash$ n. if n == 0 then 1 else f(n-1)*n) fix$_f$ 0) * 1) * 2=   --def of if then else\newline
((($\backslash$ f. $\backslash$ n. if 0 == 0 then 1 else f(n-1)*n) fix$_f$ 0) * 1) * 2 =  -- def of beta reduction\newline
((1) * 1) * 2 =  --def of arithmetic\newline
(1 * 1) * 2 =  --def of arithmetic \newline
1 * 2 =   --def of arithmetic \newline
2  -- def of arithmetic \newline

The answer here would simply be 2. The F fix$_f$ n function allows us to use the if/else conditional until n=0. Once n=0, we will have 1, then can compute the rest of the multiplication.


\subsection{Week 11}

\begin{verbatim}
For the final report, instead of your questions, for Week 11, write a 500 word essay on the topic.
\end{verbatim}

\noindent\newline Financial Engineering has been around since the 1990s. It is an extremely interesting topic to dive into. The article we read was about creating a functional programming language that involves many types of contracts, bonds, formulas, and more. An important thing to think about when creating a programming language that uses high level formulas and knowledge, is the fact that it must be simple enough for people who do understand how to actually use the language. I personally do not understand every single type of contract or bond, but with explanations that were provided, I can quickly understand syntax and ideas of why something is happening. 

\noindent\newline In this course, we learned about Domain Specific Languages, otherwise known as DSL’s. HTML is a DSL that is specifically designed to allow users to build websites. The difference is that we do not use HTML to perform math formulas, or other things, meaning that it has a specific use. The main form of DSL that we saw was Haskell. Haskell allowed for us to create our own or existing programming languages, which could be argued to be its specification. This idea is important because when programming languages are created, developers usually have an intended use for the language. Sometimes those intentions remain true when the language hits the market, but other times new ideas and uses of the programming language are created. In terms of the article, it is also a DSL. The specification is to build contracts and bonds, and I as we read, this is what the developers of the language built it to be. 

\noindent\newline While it would be nice for an application to have a good user interface for building contracts and bonds, this would not fall under the realm of a DSL. There are specific DSL’s to build applications, and this language that the creators made does not “build” applications, but rather they build contracts. I think that it is interesting that the creators did not use Haskell when building their programming language. Since Haskell’s DSL is to build other languages, they could in theory use Haskell to build a language that can then build applications of the contract and bond creation languages. Obviously they did not do this, but if made in the future, Haskell would be a great choice to do this.

\noindent\newline Since there is no user interface, this takes many financial experts out of the picture for actually using the language. This language is very niche, meaning that very advanced programmers would need to understand programming language theory and financial engineering, which is not an easy combination to find. However, for those specific people that can do both, they are in luck compared to the average financial expert, with a major advantage in testing contracts and bonds.

\noindent\newline Lastly, this programming language has many elements that I have seen in our own class. Denotational Semantics are relevant in all programming languages. Semantics give meaning to a language in terms of math and computing. In this article, they have many “figures” that show the semantics of their language.

\subsection{Week 12}
Week 12 was to apply the method of analysis from the lecture to
\begin{verbatim}
while (x != 0) do z:= z*y;   x:= x-1  done
\end{verbatim}

\noindent\newline\newline To start, I created my pre-condition as
\begin{verbatim}
{z = n, y = k, x = m}
\end{verbatim}

\noindent Using Hoare Logic, when a pre-condition is true P, then execute S, then Q.
\noindent Looking like this:
\begin{verbatim}
{P} S {Q}
\end{verbatim}

\noindent\newline\newline Using what I had as my pre-condition, I found the post-condition becomes
\begin{verbatim}
{z = (k^n) * m}
\end{verbatim}

\noindent\newline\newline Then I found the precondition:
\begin{verbatim}
{z = y^(m - x) * n, y = k}
\end{verbatim}
\noindent\newline and the postcondition:
\begin{verbatim}
{x = 0, z = y ^ (m - x) * n, y = k}
\end{verbatim}

\noindent\newline\newline I continued using Hoare Logic Rules, and finding Pre/Post conditions. My next precondition was:

\begin{verbatim}
{z = y^(m - x) * n, y = k, x != 0}
\end{verbatim}

\noindent\newline and postcondition:

\begin{verbatim}
{z = y^(m - x), y = k}
\end{verbatim}

\noindent\newline This was found using the While Rule.

\noindent\newline\newline The last pre and post conditions I found, using the Rule of Composition was:

\begin{verbatim}
Precondition:
{z*y = y^(m - (x-1)) * n, y = k}

Middle Condition:
{z = y^(m - (x-1)) * n, y = k}

Post Condition:
{z = y^(m - x), y = k}
\end{verbatim}


\noindent\newline To summarize all of the steps down, here is a proof tree:
\noindent\newline\includegraphics[width=185mm,scale=1.5]{prooftree}

\noindent\newline From line 4 to line 3, we can see the Assignment. From line 3 to 2 we can see the While Rule. Lastly from line 2 to 1 we see the Rule of Composition.

\section{Project}

Swift, created in 2014 by Apple, is a language predominantly to build applications for computers, phones, and more. This programming language allowed for better User-Interface and easier understanding on how to build specific ideas in the application. 
\subsection{Specification}
This project will be learning the programming language Swift. First you will find the History of Swift. Then you will find the Strengths/Weaknesses of using Swift. I will then add a relatively easy "tutorial" section on Swift. Lastly there will be a coding project done in Swift to show its capabilities. The final coding project will be an Application of a Birthday App, more on this in further sections.

\subsection{History}
The development of Swift began in 2010 by Apple Employees \href{https://nondot.org/~sabre/}{Chris Lattner}, Doug Gregor, John McCall, Ted Kremenek, and Joe Groff. They based their original idea off of many existing programming languages such as Haskell, Python, and more. The first release of Swift was in 2014, when Swift 1.0 came to market. Swift had been decided to be developed to replace Apple's earlier creation of a programming language called \href{https://en.wikipedia.org/wiki/Objective-C#:~:text=10%20External%20links-,History,Programming%20Technology%20Center%20in%201981.}{Objective-C. }\newline\newline
Using what many things that Objective-C had created earlier, Swift built many things to advance the programming world. The main intended use for Swift was to create \href{https://www.swift.org/about/}{Applications} and Games for iOS, computers, and more, mainly for Apple Products. Despite being developed by Apple, Swift can be used across many platforms, such as \href{https://www.swift.org/blog/swift-on-windows/}{Windows}, \href{https://9to5mac.com/2021/12/15/apple-releases-long-awaited-swift-playgrounds-update-with-the-ability-to-create-apps-using-ipad/} {iOS}, and \href{https://gavinw.me/swift-macos/}{macOS}. Objective-C had lacked many modern languages features, due to being created in the 1980's. Developing an entire new programming language that incorporated many of Objective-C's ideas and code snippets allowed for Swift to be created relatively quick, about 4 years. \newline\newline
 When beginning to develop Swift, Chris Lattner had noticed that popular languages such as C++ and Java had \href{https://www.hackingwithswift.com/interviews/chris-lattner-how-did-you-start-creating-swift}{bulit-in} common things such as Integers and Strings, but did not include things like arrays and dictionaries. This idea struck Lattner, and he decided that including many built-in types and functionality in the Standard Library would be an important advancement for many future langauges, and allowed for easier programming. Another important thing that the Swift development team wanted to implement was the ability to address common programming errors such as null pointer dereferencing. Many things today are still being added to the growing Swift language, but has proven to be a popular and important innovation in programing languages. In 2015, Swift ranked as the \href{https://stackoverflow.blog/2015/04/07/stack-overflow-developer-survey-2015-the-results/}{most loved programming language} in a survey amongst StackOverflow users. 
\subsection{Strengths and Weaknesses of Swift}
This section will talk about pros and cons of using Swift.
\subsubsection{Strengths}
\textbf{Speed}\newline
Swift has many strengths across many different programming language areas. One huge strength is the speed of the language, which is faster than Objective-C and \href{https://www.geeksforgeeks.org/difference-between-python-and-swift/}{Python}. Apple even claims that Swift is \href{https://www.apple.com/swift/}{8.4 times faster} than Python. Having this much of an advantage in the speed category for programming languages is important in computing. This speed superiority exists because of the ability for Swift to detect specific errors, and how their compiler was constructed. Swift was built with \href{https://www.altexsoft.com/blog/engineering/the-good-and-the-bad-of-swift-programming-language/}{LLVM compiler framework}, which translates to machine code from the assembly language. The Machine code then optimizes the code, which allows for much faster speeds than other highly popular programming languages.\newline\newline

\noindent \textbf{Apple-Supported} \newline
Swift, being developed by Apple, is highly used to create Applications and Games for Apple Products. Apple is a huge brand, so having the ability to be backed by one of the biggest companies in the world, makes the language of Swift to be much more valuable to learn. The language is growing, and will continue to be supported by Apple to make it better. By learning Swift, it is much more likely that it will continue to grow in the future and will not die out. This means that people can learn and develop in Swift, without worrying that coding in Swift could become outdated.\newline \newline

\noindent \textbf{Open-Source} \newline
Open-Source programming languages are very important and beneficial for coding. Open-Source allows for \href{https://enterprisersproject.com/article/2015/1/top-advantages-open-source-offers-over-proprietary-solutions}{flexibility}, cost-effective, and allows for better future of the language. It also allows for developers to get access to community resources, debuggers, package managers, and supporting libraries. There are popular langauges such as \href{https://www.analyticsinsight.net/top-10-programming-languages-for-open-source-projects-in-2021/}{Java}, Python, C++, and as you would expect, \href{https://www.outsource2india.com/software/mobile-applications/articles/apple-swift-now-open-source.asp}{Swift}. Being Open-Source is a huge advantage over many other programming languages that do not having Open-Source because developers will have an easier understanding on the deeper knowledge of a language, and a more lively community that discuss how to make Swift an even better language. \newline \newline

\noindent \textbf{Simple Syntax} \newline
The ability to easily learn and use a programming language is important. Simple syntax languages such as Python are often some of the first languages developers learn due to the simplicity of the code. Swift is very similar in many aspects to Python, but also has its own uniqueness. Swift can easily be ran without having classes, a main method, and importing many things. This allows for first time users to understand the syntax much faster, and thus the language gets much more popular than harder to learn languages. Simple Syntax languages are languages that are easy to read, and do not require extra characters and commands, such as semi-colons and more. \newline

\subsubsection{Weaknesses}
\textbf{Years on Market}\newline
Swift is a very young language. Many older languages that can continue to keep its popularity, such as C and C++, have large communities and developers who were exposed to using them early on. Swift has only be available for 8 years, which is quite young. As this is a weakness now, Swift is growing popularity extremely fast and will continue to grow as previously mentioned. The community for C++ is much larger, and thus more users have found bugs, corrections, and more. Swift has more to be discovered about itself, as C++ has discovered plenty. Swift is currently used to develop primarily Apple Applications, but in the future it could be discovered that it is better for other uses that the Apple developers had not thought of. \newline \newline

\noindent\textbf{Backward Compatibilty}\newline
As Programming Languages evolve for the better, there are many times when developers are stuck on older versions due to their choice, or not updating before writing their code. However, this could be a real problem for Swift. Apple has made it clear to engage users with their newest OS, iOS, and new versions of anything, without looking for backward compatibility to be their biggest concern. This is very prevelant with Swift, as the language gets new versions, there will be some parts of the new update that will not work great with older versions. This is a problem for now, but currently Apple is creating a \href{https://medium.com/@carlos.banos85/swift-5-5-concurrency-backward-compatibility-884fd9c284da}{back deployment library} now to fix these version problems. This weakness will eventually be fixed or at least better than before.

\subsection{Easy-To-Learn-Swift}
When learning Swift, I found that it had elements of other languages sprinkled in to make it feel similar. There are many things that can be done in Swift, such as \href{https://www.airpair.com/swift/building-swift-app-tutorial}{Application Building}, \href{https://caiocnoronha.medium.com/games-in-swift-88a72e441537}{Game Development}, and more. I am going to give some very basic syntax, examples, and questions about Swift.

\subsubsection{Basic Syntax}
\textbf{Variables}\newline
\noindent There are two main ways of declaring a variable in Swift. The first is to use \textbf{var}.
\begin{verbatim}
var a = 1
\end{verbatim}
\noindent As you would expect, the variable a now has the value of \textbf{1}. \textbf{var} allows for manipulation of the variable, rather than keeping \textbf{a} with the value of only \textbf{1}. For example, we can do:
\begin{verbatim}
var a = 1
a = 3
\end{verbatim}

\noindent Now \textbf{a} would have the value \textbf{3}. 

\noindent\newline\newline \textbf{var} does not need to have an immediate value, however it must be declared with a \textbf{data-type}, or type. We will get into the standard \textbf{data-types} later, but many times programmers will want to declare a variable, but not actually give it any information.

\begin{verbatim}
var b:Int
\end{verbatim}
\noindent The variable \textbf{b} would not have any value, but it can only become an Int Data-Type now. 

\noindent\newline\newline \textbf{Question: What value would the variable 'c' be?}
\begin{verbatim}
var d = 3
var c = 4
d = 5
c= 6
\end{verbatim}

\noindent\newline \textbf{Answer: 6}


\noindent\newline\newline \textbf{let} is another way of declaring a variable. The difference between \textbf{let} and \textbf{var} is that \textbf{let} will not allow for variable manipulation after receiving the initial value. This is a common concept across programming languages, as form of a constant. 

\noindent\newline Here is a straightfowared example of using \textbf{let} to declare a variable
\begin{verbatim}
let a = 2
\end{verbatim}

\noindent\newline Here, the variable \textbf{a} would be the value of 2.

\noindent\newline\newline However, you must be careful when using \textbf{let}. It should only be used if the variable is 100 percent not being changed. If you do, like this upcoming example, there will be an error.
\begin{verbatim}
let a = 5
a = 2
\end{verbatim}
\noindent\newline The variable \textbf{a} has already been assigned the value of 5, and since it was initialized with \textbf{let} and not \textbf{var}, it can not be manipulated. This would result in an error.

\noindent\newline\newline \textbf{Question: Will these lines result in an error?}
\begin{verbatim}
let a = 2
var b = 3
b = a
\end{verbatim}

\noindent\newline \textbf{Answer: No. The variable 'b' was initialized with var, allowing it to be manipulated.}


\noindent\newline\newline\newline \textbf{Data-Types}\newline
\noindent In this section we will talk about the standard Data-Types that is included with Swift. Swift supports Int, String, Float, Double, Bool, and Character. These Data-Types are common across many programming languages. Variables that use a Data-Type, can only use that Data-Type. For example, a variable \textbf{a} that was of type String, would not be able to store the Int value of 3.

\noindent\newline\newline Int is a Data-Type that is a Whole Number. Variables can be Int's, or they can be introduced into math formulas in Code. Here is an example:

\begin{verbatim}
var a:Int
a = 2
\end{verbatim}
\noindent\newline This would simply allow the variable \textbf{a} to be the Int value of 2.

\noindent\newline Here is another example:
\begin{verbatim}
var a:Int = 2
var b:Int

b = a + 1

\end{verbatim}
\noindent\newline Here the variable \textbf{b} would be assigned with the value 2. This also introduces the basic Arithmetic that is included with Int. +, -, *, / are all used for Int, Floats, and Double Data-Types, and do addition, subtraction, multiplication, and division.

\noindent\newline\newline \textbf{Question: What value would the variable 'c' be?}
\begin{verbatim}
let a:Int = 2
var b:Int
b = a * a
var c:Int
c = b + 1
\end{verbatim}

\noindent\newline\textbf{Answer: 5}

\noindent\newline\newline\textbf{String} is another important Data-Type. It is a collection, or list, of the Character Data-Type. A Character Data-Type is simply just a letter, number, symbol. The String comprises of multiple Characters, to make one large String.

\noindent\newline Here is how to initialize a \textbf{String}:
\begin{verbatim}
var a:String
a = "Hello World"
\end{verbatim}

\noindent\newline Here the variable \textbf{a} would be \textbf{Hello World}. 

\noindent\newline\textbf{String Methods} are also important to understand. Here are a few quick examples.

\noindent\newline \textbf{String Concatination}
\begin{verbatim}
let first:String = "Everett"
let last:String = "Prussak"

var name:String
name = first + " " + last
\end{verbatim}
\noindent\newline The variable \textbf{name} would consist of \textbf{Everett Prussak} as one entire string.

\noindent\newline \textbf{String Accessing}
\begin{verbatim}
let first:String = "Everett"
var ch:Character

ch = first[0]
\end{verbatim}
\noindent\newline The variable \textbf{ch} would consist of the character \textbf{E}.

\noindent\newline \textbf{String Length}
\begin{verbatim}
let first:String = "hello"
var length:Int

length = first.count
\end{verbatim}
\noindent\newline The variable \textbf{length} would consist of \textbf{5} as an Int.

\noindent\newline\newline \textbf{Print Statement}
\noindent\newline Another important thing to understand about Swift is the print statement. It is straight forward if you have used the print statement in Python. Simply to write something to terminal, the command:
\begin{verbatim}
print("Hello World")
\end{verbatim}
\noindent can be ran. The terminal will now have Hello World appear. As I explain in upcoming sections, we will be using something called SwiftUI to help simulate the application. This is not important for now, but print will not be seen in my project code, but instead the term \textbf{Text}. This is because we are not printing to the terminal, but instead directly onto the screen/View.

\noindent\newline\newline \textbf{Remark}
\noindent\newline Overall, Swift is a fairly easy language to understand, if prior coding languages have been learned. There are many things to write about Swift, meaning that there is much more to research if you are interested. As mentioned before, Swift is a growing language, so this quick tutorial can possibly ignite somebody to want to learn more. I never go into other things such as Classes, Structures, Imports, and more. 



\subsection{Project Overview}
The project that I will be making in Swift will be an Application. The Application will consist of a User Adding Contacts/Friends into their own database, that consists of their name, birthday, description, and other features. The main idea of this App is to keep track of Birthdays. Similar to a contacts app on an iOS, once a person is added, they can be clicked on and their information can be displayed on the screen. This project consisted of multiple parts. The first was to understand and learn the basic syntax of Swift. The next step was to understand more complex teachings, such as Classes, Objects, and more. I then researched the History of Swift, and some Strengths and Weaknesses, which was read earlier. Lastly was the report that was previously mentioned.

\subsection{Final Project}
The Application that I built can be seen in my \href{https://github.com/everettprussak/CPSC354}{GitHub} under report code folder. The file birthday.swift is what I will be referring to as Birthday App. The Birthday App is a very simple idea, the ability to add friends into a personal database that holds information regarding name, birthday month, birthday year, and birthday day. The User will have the ability to add friends, edit friends, display friends information, add information about a friend, ability to click on a friend, and see a list of all friends. When greeted, the app will be relatively blank. This is because the user has not entered any friends into the app yet. The app is fully engaged by what the User wants to add and edit. 

\subsection{Project Images}
\includegraphics[width=35mm,scale=0.2]{OpeningImage}\noindent\newline 1. When opening the app for the very first time, you will be meet with this screen. I decided to keep the set up relatively simple. As you can see, the only option here would to be click \textbf{Add Friend} on the bottom. Let's do that.\newline\newline

\includegraphics[width=35mm,scale=0.2]{AddFriend}\noindent\newline 2. Here you can see the options we have to create a Friend. We can enter their name, and pick their month, day, and year of their birthday. \newline\newline

\includegraphics[width=35mm,scale=0.2]{FriendInformation}\noindent\newline 3. This is how a User would want to add a Friend of the name Everett Prussak, who was born in December 2001, on the 26th. Simply to save this contact, click \textbf{Save} on the bottom. \newline\newline

\includegraphics[width=25mm,scale=0.2]{MonthChoices}\noindent\newline 4. This how the options of selecting the month for the added contact. Instead of having names of each month, it was easiler to keep track of Integer data. I decided to have months in their Integer Value rather than String Value. \newline\newline

\includegraphics[width=35mm,scale=0.2]{FriendAdded}\noindent\newline 5. Now, we added the Friend \textbf{Everett Prussak}. We can added another friend, or instead we will simply click the friend.\newline\newline

\includegraphics[width=35mm,scale=0.2]{Information}\noindent\newline 6. We will be brought to this screen. It will display the current day, and it will also display the information that we entered. We can either go back to the list view of the contacts or edit the information for this specific person.


\subsection{Code Walkthrough}
\noindent This Application took many hours of research, testing, ideas, and more. I am going to explain many of the design ideas and code blocks in this section.

\subsubsection{SwiftUI}
At the very start of my code, you will notice the line:
\begin{verbatim}
import SwiftUI
\end{verbatim}

This line is extremely important in the Application Building Process. As Swift is the language that this code is written in, SwiftUI allows for multiple views of a Swift File. As you will read in the upcoming sections, the app I built has many \textbf{Views}. A \href{https://cocoacasts.com/swiftui-fundamentals-what-is-a-view}{View} is a piece of the application's user interface. Almost every image from above was its own \textbf{View}. Think about a view as a new page of a Website, where we understand we are still on the website, but another \textbf{view}, or page of it. By importing SwiftUI, it allows swift file to conform this type of programming.

\subsubsection{User}
The next section is this structure called \textbf{User}. A structure, or \href{https://www.programiz.com/swift-programming/structs#:~:text=In%20Swift%2C%20a%20struct%20is,same%20information%20of%20multiple%20people.}{Struct}, is used to store variables of different data types. 
\noindent A Struct is very similar to a Class, but Classes are reference types, while structs are value types.
\begin{verbatim}
struct User: Identifiable{
    let id = UUID()
var name:String
var month:Int
var day:Int
var year:Int
    let id_a:Int
}
\end{verbatim}

\noindent\newline Inside of this code, we have a structure that conforms to be \textbf{Identifiable}. This is telling the struct to that this \textbf{User} has to be identifiable, meaning that it must have a unique ID. This brings us to the line of:
\begin{verbatim}
let id = UUID()
\end{verbatim}
This line creates a Unique ID for each User that is created, using the UUID() method. 

\noindent\newline The rest of the lines of code are pretty common across programming languages. This struct is creating a User, that has a name in the Data-Type of a String, month, day, year, and id a, in the Data-Type of an Int. 

\subsubsection{UserContainer}
This section of code seems small at a glance, but contains one of the most important lines in the entire program.
\begin{verbatim}
class UserContainer: ObservableObject{
    @Published var users = [User]()
}
\end{verbatim}
This block of code is the only \textbf{Class} in the entire program. The class \textbf{UserContainer} conforms to \textbf{ObservableObject}. A \href{https://www.hackingwithswift.com/quick-start/swiftui/how-to-use-observedobject-to-manage-state-from-external-objects}{Observable Object} allows instances of the class UserContainer to be made available inside of Views. It is very important because when something needs to be updated from a View, it must conform to be a ObservableObject. 

\noindent\newline The next line that contains @ which represents an attribute. The term \textbf{Published} is also extremely important. Published is a wrapper that is to be used inside a class that is an ObservableObject. By making the variable users an attribute of type Published, will allow every view that contains this Object to update when it gets updated. For example, when I edit the name of a contact, It will go inside of the list we just made of type Users, and update the individual name. Then across the views, this specific shared Object will be updated automatically. 

\subsubsection{ContentView}
The next section of my code is the \textbf{ContentView}. This can be seen as the \textbf{main} method, or class, for many programs. When the program starts, the first line will begin here in ContentView. ContentView has many variables, and features. A main thing about using ContentView is the ability to switch from the ContentView to other views. When we see a list of our friends when we open the app, this is our ContentView, and once we click onto the name to go to another view, specific lines and variables are being executed to go to a new View representing the friends information.

\begin{verbatim}
struct ContentView: View{
    @ObservedObject var usersContainer = UserContainer()
    
    @State var navi = false
    
    @State var personalView = false
    
    @State var i = UUID()
    
    @State var id_string:String = ""
    
    var id_num:Int = -1
    
    @State var num1:Int = 0
    
    @State var person:User = User(name:"d",month:1,day:1,year:2000,id_a:1) 
    
    var body: some View {
        NavigationView{
            List(usersContainer.users, id: \.id){
                user in
                Button(user.name){
                    num1 = user.id_a
                    person = user
                    personalView.toggle()
                }
            }
            .sheet(isPresented: $personalView){
                Personal(usersContainer: usersContainer, person_id: num1, person:person, navi:false)
            }
            .sheet(isPresented: $navi){
                AddingView(usersContainer: usersContainer, navi: false)
            }
            .navigationBarTitle(Text("Your Friends"))
    }
        Button("Add Friend"){
            navi.toggle()
        }
        .padding()
    }
}
\end{verbatim}

\noindent\newline The variable usersContainer that has the attribute \textbf{ObservedObject} is another important variable in the program. As we saw in the prior section, the class UserContainer conformed to be a ObservableObject. That means when we initiate the UserContainer class inside ContentView, we want to be share this specific variable across views. Think about the ObservedObject as a \textbf{Public} variable inside of class. We would understand that this public variable can be accessed across classes and the main method. 

\noindent\newline Another important line is the variable that has the property wrapper \textbf{State} that is set to the boolean expression of false. With the property wrapper, State, we are allowed to manipulate the value for the variable inside the struct. Without certain property wrappers, Swift will not allow for manipulation in Struct's once the variable is set. This means that the variable \textbf{navi} is false at the start, but inside of the ContentView Struct we can manipulate is true and false.

\noindent\newline This will be our first look at the line:
\begin{verbatim}
var body: some View {
\end{verbatim}
\noindent\newline This line is telling us that the body of our Struct is implementing the View protocol. In simpler terms, inside this body is where the first 'page' of our Application will take place. This line will take place in any of our other Views.

\noindent\newline Inside of our ContentView's View, we have:
\begin{verbatim}
        NavigationView{
            List(usersContainer.users, id: \.id){
                user in
                Button(user.name){
                    num1 = user.id_a
                    person = user
                    personalView.toggle()
                }
            }
\end{verbatim}
\noindent\newline The term \href{https://bignerdranch.com/blog/the-different-forms-of-navigation-in-swiftui/}{NavigationView} allows for multiple buttons, lists, text blocks, and more in the View. Inside of this NavigationView we have a list of the Friends that the user has, and turns each name of each friend into a clickable button. When clicked, the button command will occur and will bring us to personalView.toggle().

\noindent\newline As we move on, these are the last important lines for ContentView:
\begin{verbatim}
            .sheet(isPresented: $personalView){
                Personal(usersContainer: usersContainer, person_id: num1, person:person, navi:false)
            }
            .sheet(isPresented: $navi){
                AddingView(usersContainer: usersContainer, navi: false)
            }
            .navigationBarTitle(Text("Your Friends"))
    }
        Button("Add Friend"){
            navi.toggle()
        }
\end{verbatim}   
\noindent\newline While these lines look complicated, they are quite easy to understand. When we use the command .toggle(), like we did in the code right before this, we will go to this part of the code. Since we had personalView.toggle(), we will go inside the sheet, and then call the View \textbf{Personal}. This is telling us that when we click on a name in our list on ContentView, to turn the variable personalView from false to true. This then allows us to give the view Person the contents of the person who was clicked on. This is similar with the variable navi. When navi is clicked on, from the Add Friend Button, we will turn navi from false to true and go to the AddingView. The toggle feature is an extremely important method to understand if an application has multiple views.

\noindent\newline That is the basics for ContentView. We will not be moving into AddingView, which means that the user clicked the \textbf{Add Friend} button. This then toggle the variable navi, and allowed us to go to AddingView.

\subsubsection{AddingView}

AddingView is our next View I will be talking about. As ContentView is looked at as our main method, AddingView can be looked at as a function of some sort. I explained how we get from ContentView to AddingView using .toggle() on specific variables, but as we enter AddingView specific variables must be passed. When we call AddingView, the most important variable \textbf{usersContainer} must be passed. This is because we are now manipulating the list of users by appending a new friend. Here is the code, I will talk about each section.

\begin{verbatim}
struct AddingView: View{
    
    @ObservedObject var usersContainer: UserContainer
    
    @State var name:String = ""
    
    @State var month:Int = 0
    
    @State var day:Int = 0
    
    @State var year:Int = 0
    
    @State var num1:Int = 0
    
    @State var navi:Bool = false
    
    let month_choices = [1,2,3,4,5,6,7,8,9,10,11,12]
    let day_choices = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]
    
    let year_choices = [2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022]
    
    var body: some View{
            VStack{
                Text("Adding Friend")
                TextField("Name",text:$name)
                    .padding(15)
                    .background(Color(.systemGray6))
                    .cornerRadius(75)
                Text("Select Month")
                Picker("Select Month", selection: $month) {
                    ForEach(month_choices, id: \.self) {
                        Text(String($0))
                    }
                }
                .pickerStyle(.menu)
                Text("Select Day")
                Picker("Select Day", selection: $day) {
                    ForEach(day_choices, id: \.self) {
                        Text(String($0))
                    }
                }
                .pickerStyle(.menu)
                Text("Select Year")
                Picker("Select Year", selection: $year) {
                    ForEach(year_choices, id: \.self) {
                        Text(String($0))
                    }
                }
                .pickerStyle(.menu)
                
                Button("Save"){
                    self.num1 = self.usersContainer.users.count
                    self.usersContainer.users.append(User(name:name, month:month, day:day,year:year, id_a: num1))
                    navi.toggle()
                }
                .sheet(isPresented: $navi){
                    ContentView(usersContainer: usersContainer, navi: false, num1: num1)
                }
        }
    }
}
\end{verbatim}

\noindent\newline The first section will be these lines:

\begin{verbatim}
    @ObservedObject var usersContainer: UserContainer
    
    @State var name:String = ""
    
    @State var month:Int = 0
    
    @State var day:Int = 0
    
    @State var year:Int = 0
    
    @State var num1:Int = 0
    
    @State var navi:Bool = false
\end{verbatim}

\noindent\newline The first important thing is the variable usersContainer. This is the exact same as the usersContainer from ContentView. Since it is an ObservedObject, we are allowed to manipulate, change, add, delete, and more to the this type of variable. There are also several State variables that are used to hold data from the user when they enter information about the friend they are adding. For example, when they enter the name of the friend, the variable \textbf{name} will be updated from an empty string to name entered. Another important variable is the navi variable. This variable is used for the same reason as last time, which allows us to toggle it, then go to a new view. We will see later which View we want to go to, but it is fundamentally the same as ContentView's navi variable.

\noindent\newline The next section will consist of:
\begin{verbatim}
var body: some View{
            VStack{
                Text("Adding Friend")
                TextField("Name",text:$name)
                    .padding(15)
                    .background(Color(.systemGray6))
                    .cornerRadius(75)
                Text("Select Month")
                Picker("Select Month", selection: $month) {
                    ForEach(month_choices, id: \.self) {
                        Text(String($0))
                    }
                }
                .pickerStyle(.menu)
                Text("Select Day")
                Picker("Select Day", selection: $day) {
                    ForEach(day_choices, id: \.self) {
                        Text(String($0))
                    }
                }
                .pickerStyle(.menu)
                Text("Select Year")
                Picker("Select Year", selection: $year) {
                    ForEach(year_choices, id: \.self) {
                        Text(String($0))
                    }
                }
                .pickerStyle(.menu)
                
                Button("Save"){
                    self.num1 = self.usersContainer.users.count
                    self.usersContainer.users.append(User(name:name, month:month, day:day,year:year, id_a: num1))
                    navi.toggle()
                }
                .sheet(isPresented: $navi){
                    ContentView(usersContainer: usersContainer, navi: false, num1: num1)
                }
        }
    }
\end{verbatim}
\noindent\newline This is the rest of the AddingView struct. As we can see, we have the will have the body implement the View protocol. Inside of that we have a \href{https://developer.apple.com/documentation/swiftui/vstack}{VStack}. Similar to NavigationView, it allows for multiple text boxes, images, and more to be displayed on one view. In our VStack, we will have a few TextField's that allow the user to enter information about the Friend. These TextField's and Text boxes will store the correct information into each variable. For example, when the user types the name of their friend they are adding, it will automatically store the name inside the local state variable, \textbf{name}. After everything is added, the user must click the Save button to save the information. This step was a very interesting and hard step for me to understand originally. It took many trials with ObservedObjects, passing variable, learning how to use buttons and more, but I ultimately figured it out. Since we have an ObservedObject of usersContainers, we can directly add our information into a new user, then append that user to usersContainer. This will allow the user, or friend, added to be saved internally across all views. After that, the navi variable is toggled, and we simply pass usersContainers back to ContentView.

\subsubsection{Personal}

The next view I will be talking about is called \textbf{Personal}. This follows the same general pattern as the other two views. That being the main ObservedObject variable, several state variables, and the body that implements the View protocol. Personal is the View toggled by ContentView when a specific person in our list is clicked. This prompts the View to show the information added by the user.

\begin{verbatim}
struct Personal: View{
    @ObservedObject var usersContainer:UserContainer
    
    @State var person_id:Int = 0
    
    var person:User
    
    @State var navi = false
    
    @State var now = Date.now
    
    @State var edit = false

    var body: some View {
        NavigationView{
        VStack{
            //Text(String(person_id))
            //Text(usersContainer.users[person_id].name)
            Text("Today")
            Text(Date.now, format: .dateTime.day().month())
            Text("")
            Text("Birthday")
            //Text(String(person_id))
            Text("Month: " + String(usersContainer.users[person_id].month))
             Text("Day: " + String(usersContainer.users[person_id].day))
            Text("Year: " + String(usersContainer.users[person_id].year))
             
            Button("Edit"){
                edit.toggle()
            }
            .sheet(isPresented: $edit){
                EditView(usersContainer: usersContainer, person_id: person_id, navi:false)
            }
        }
        .navigationTitle(usersContainer.users[person_id].name)
        }
        Button("Back"){
            navi.toggle()
        }
        .padding()
        .sheet(isPresented: $navi){
            ContentView(usersContainer: usersContainer, navi: false, num1: person_id)
        }
    }
}
\end{verbatim}

\noindent\newline Inside of our body, we have many lines of Text. These lines are simply for formatting purposes and printing the information to the screen of the iOS device. Since usersContainer is simply an array of all of the friends, I use the index of their userID to print the information. There are two buttons on the screen under all of the information, \textbf{Back} and \textbf{Edit}. The back button will simple toggle the variable navi and take us back to the ContentView. However, when Edit is clicked, the variable edit is toggled. This will take us to our last View called EditView.


\subsubsection{EditView}

This is the last View and part of the program. Again, very similar to our other three views, in fact EditView is almost identical to AddingView. The only main difference is that instead of adding a user to our usersContainer, we are editing the current one. The screen will look the exact same as AddingView, but the details in the code are slightly altered to allow for a manipulation of the friend that is desired to be edited.

\begin{verbatim}
struct EditView: View {
    @ObservedObject var usersContainer:UserContainer
    
    @State var person_id = 0
    
    @State var month:Int = 0
    
    @State var name:String = ""
    
    @State var day:Int = 0
    
    @State var year:Int = 0
    
    @State var num1:Int = 0
    
    @State var navi:Bool = false
    
    let month_choices = [1,2,3,4,5,6,7,8,9,10,11,12]
    let day_choices = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]
    
    let year_choices = [2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022]
    
    var body: some View{
        VStack{
            Text("Adding Friend")
            TextField("Name",text:$name)
                .padding(15)
                .background(Color(.systemGray6))
                .cornerRadius(75)
            Text("Select Month")
            Picker("Select Month", selection: $month) {
                ForEach(month_choices, id: \.self) {
                    Text(String($0))
                }
            }
            .pickerStyle(.menu)
            Text("Select Day")
            Picker("Select Day", selection: $day) {
                ForEach(day_choices, id: \.self) {
                    Text(String($0))
                }
            }
            .pickerStyle(.menu)
            Text("Select Year")
            Picker("Select Year", selection: $year) {
                ForEach(year_choices, id: \.self) {
                    Text(String($0))
                }
            }
            .pickerStyle(.menu)
            
            Button("Save"){
                //self.num1 = self.usersContainer.users.count
                //self.usersContainer.users.append(User(name:name, month:month, day:day,year:year, id_a: num1))
                self.usersContainer.users[person_id].name = name
                self.usersContainer.users[person_id].month = month
                self.usersContainer.users[person_id].day = day
                self.usersContainer.users[person_id].year = year
                navi.toggle()
            }
            .sheet(isPresented: $navi){
                ContentView(usersContainer: usersContainer, navi: false, num1: num1)
            }
            Button("Cancel"){
                navi.toggle()
            }
        }
    }
    
}

\end{verbatim}

The main takeaway from EditView is when we click the Save button, we are changing the information in the userContainer, rather than appending. Almost everything else is the exact same as AddingView, and follows the same general pattern.

\subsection{Future Plans}
As CPSC 354 is ending, this project will not. I want to continue to make this Application for practice and possibly put it on the Apple AppStore. The steps to add an App on the AppStore are not very complicated, and I think that people could realistically use this App. 

\noindent\newline Some things that I will continue to add are as follows:
\begin{itemize}
  \item Ability to Delete Friends
  \item Notify user when it is one of their Friends birthday
  \item Notify a week before it is one of their Friends birthday
  \item Make ContentView more exciting looking for the user
  \item When viewing a Friends information, have the ability to send a message or email when it is their birthday.
\end{itemize}

\subsection{Documentation}
All sources used is credited in the Bibliography under the \textbf{Report Sources}. You can see the Company, Name of Author (If found), and Date.

\subsection{Critical Appraisal}
Quick Note: This project took many hours of research, trial, errors, successes, and more. I originally wanted to create a tracking application, but I found that it would not be a very realistic process. I understand that the Birthday App is not a very exciting idea, but learning Swift was not an easy task. I am proud of what I created here, and I hope to continue it in the future. 

\noindent\newline There are no current bugs or errors in the code provided. 

\noindent\newline Interesting Info:
\noindent\newline When building this project, the simulator I used was often very glitchy. For example, many times I would write correct code, but it would mark it as an error, before I have to redo the entire line, then it works. I am not sure if this just because the simulator is faulty due to runtime being constant, or for other reasons. This would be an interesting topic to dive deep into.

\noindent\newline Another interesting thing I found was how much power something with constant runtime took. My computer would get extremely hot from using Swift Playgrounds to test my code. In theory it makes that constant runtimes will be so extraneous on a computer, but I also think that my final product had much more I want to implement. I may start editing and programming in other code editors, such as Atom or VSCode, then pasting it back into the simulation to find errors.

\noindent\newline The last interesting thing I found was the use of Attributes and Property Wrappers used in Swift. As mentioned in the History section, Swift is a relatively new programming language, so I was surprised to find many new things that I have not had much experience with. Using C++, Java, and Python, I have never had to express that a variable or class itself is an ObservedObject and so on. I think this concept is interesting, and once you understand it, it allows for a lot of organization of each variable. I personally like this concept of programming, even though I am sure it is more common than I would know of.  


\section{Conclusions}\label{conclusions}

Personally, this is one of the most rigorous classes I have ever taken. At first I was shocked on how hard the first Assignment was. However, after each lecture I would slightly understand the class more and more. By the second Assignment I quickly understood even more about why we are doing each task and how to implement it. By the last Assignment I found it much easier than the first two due to understanding so much more about programming languages than before. I felt like I have learned more in this class than I have in any other class, and the material taught was extremely important to take to other classes and hopefully a future job. 

\noindent\newline I found this Report Style of class versus the traditional Exam, Quiz, and Assignment heavy course interesting. It was less stressful than having an Exam every month, but it was more stressful in the week when planning each step of my project and putting in more research on one specific thing than I ever have. Each Homework step stoned into the next Homework, Assignment, and Idea for my Project. 

\noindent\newline The project was a very difficult task to complete, but I found it quite enjoyable. It was an entire process of research, learning, and implementation that I have not had before. The number of sources I used to give definitions, site, and more was much more than other essays I have written.

\noindent\newline This course fits into the wider world of programming languages and software engineering in a variety of ways. The first thing I took away was the process of an Interpreter. The idea of an Interpreter is not hard to grasp, but the actual code and theory behind it was. Assignment 2 was the main catalyst to actually implementing and understanding the process behind the Interpreter. Another important thing was Domain Specific Languages. Before this course, I did not understand that many languages were used for oddly specific things. For example, the Financial Engineering was a topic I had no understanding in prior, but now I understand that a DSL for Financial Engineering contracts, bonds, and more exist. I assume there are many DSL's that have specific uses that I will use in the professional world, which is important to understand. 

\noindent\newline To conclude, I appreciate all of the information that I was taught this year. This course taught me many theories, interesting views, and more things I have not mentioned. This course was incredibly far from what I was expecting to learn. I hope you enjoyed reading my Report. Thank you for the great semester Professor Kurz!

\begin{thebibliography}{99}

\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/README.md}{Programming Languages 2022}, Chapman University, 2022.\newline
\newline
\textbf{Homework Sources} \newline
\href{https://hackmd.io/@alexhkurz/H1jUka4Gv#fn2}{Hackmd.io} Professor Kurz, Chapman University 2022\newline\newline
\href{https://www.mathsisfun.com/games/towerofhanoi.html}{Tower of Hanoi} Math Is Fun, 2021 \newline

\textbf{Report Sources}\newline
\textbf{History Section}\newline
\href{https://en.wikipedia.org/wiki/Objective-C#:~:text=10%20External%20links-,History,Programming%20Technology%20Center%20in%201981.}{Objective-C.} Wikipedia, 2022\newline
\href{https://nondot.org/~sabre/}{Chris Lattner's Homepage} Chris Lattner, 2022\newline
\href{https://www.swift.org/about/}{Swift About Page} Apple, 2022\newline
\href{https://www.swift.org/blog/swift-on-windows/}{Introducing Swift on Windows} Apple, 2022\newline
\href{https://9to5mac.com/2021/12/15/apple-releases-long-awaited-swift-playgrounds-update-with-the-ability-to-create-apps-using-ipad/}{Swift on iOS} 9 to 5 Mac, Jose Adorno, 2021 \newline
\href{https://gavinw.me/swift-macos/}{Swift on macOS} Gavin Wiggins, 2022 \newline
\href{https://www.hackingwithswift.com/interviews/chris-lattner-how-did-you-start-creating-swift}{Chris Lattner Interview} Hacking With Swift, 2020\newline
\href{https://stackoverflow.blog/2015/04/07/stack-overflow-developer-survey-2015-the-results/}{Programming Languages Survey} StackOverflow, 2015\newline

\textbf{Strengths/Weaknesses Section}\newline
\href{https://www.geeksforgeeks.org/difference-between-python-and-swift/}{Swift Speed} Geeks For Geeks, 2021 \newline
\href{https://www.apple.com/swift/}{Swift Speed Comparison} Apple, 2022\newline
\href{https://www.altexsoft.com/blog/engineering/the-good-and-the-bad-of-swift-programming-language/}{Swift Compiler} Altexsoft, 2021\newline
\href{https://enterprisersproject.com/article/2015/1/top-advantages-open-source-offers-over-proprietary-solutions}{Open-Source Pro's} The Enterprisers Project, Lee Congdon, 2015 \newline
\href{https://www.analyticsinsight.net/top-10-programming-languages-for-open-source-projects-in-2021/}{Open-Source Programming Languages} Analytics Insight, 2021 \newline
\href{https://www.outsource2india.com/software/mobile-applications/articles/apple-swift-now-open-source.asp}{Swift is now Open-Source} OutSource2India \newline
\href{https://medium.com/@carlos.banos85/swift-5-5-concurrency-backward-compatibility-884fd9c284da}{Apple building Backwards Compatibility} Medium, Carlos Banos, 2021 \newline

\textbf{Easy-To-Learn}\newline
\href{https://www.airpair.com/swift/building-swift-app-tutorial}{Swift App Tutorial} AirPair, Jack Watson-Hamblin, 2015 \newline
\href{https://caiocnoronha.medium.com/games-in-swift-88a72e441537}{Games in Swift} Normal, Caio Noronha, 2020\newline

\textbf{Code Walkthrough}\newline
\href{https://cocoacasts.com/swiftui-fundamentals-what-is-a-view}{View} CocoaCasts, 2021 \newline
\href{https://www.programiz.com/swift-programming/structs#:~:text=In%20Swift%2C%20a%20struct%20is,same%20information%20of%20multiple%20people.}{Struct Definition} Programiz \newline
\href{https://www.hackingwithswift.com/quick-start/swiftui/how-to-use-observedobject-to-manage-state-from-external-objects}{ObservableObject} Hacking With Swift, Paul Hudson, 2021\newline
\href{https://bignerdranch.com/blog/the-different-forms-of-navigation-in-swiftui/}{NavigatioView} Big Nerd Ranch, Mark Dalrymple, 2022\newline
\href{https://developer.apple.com/documentation/swiftui/vstack}{VStack Definition} Apple, 2022\newline

\end{thebibliography}

\end{document}