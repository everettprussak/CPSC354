
\documentclass{article}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-354 Report}
\author{Everett Prussak  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Short  summary of purpose and content.  Must Do soon.
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}

This report consists of Homework and the main project for CPSC 354. Section 1 consists of an introduction to LaTeX from Professor Kurz. Section 2 consists of homework for each week. Section 3 consists of the project. Section 4 consists of the sources, references, and websites cited.

\subsection{General Remarks}

First you need to \href{https://www.latex-project.org/get/}{download and install} LaTeX.\footnote{Links are typeset in blue, but you can change the layout and color of the links if you locate the  \texttt{hypersetup} command.}
%
For quick experimentation, you can use an online editor such as \href{https://www.overleaf.com/learn}{Overleaf}. But to grade the report I will used the time-stamped pdf-files in your git repository.  

 
\medskip\noindent
LaTeX is a markup language (as is, for example, HTML). The source code is in a \verb+.tex+ file and needs to be compiled for viewing, usually to \verb+.pdf+.


\medskip\noindent
If you want to change the default layout, you need to type commands. For example, \verb+\medskip+ inserts a medium vertical space and \verb+\noindent+ starts a paragraph without indentation.
 
\medskip\noindent
Mathematics is typeset between double dollars, for example $$x+y=y+x.$$


\subsection{LaTeX Resources}

I start a new subsection, so that you can see how it appears in the table of contents.

\subsubsection{Subsubsections}

Sometimes it is good to have subsubsections.

\subsubsection{Itemize and enumerate}

\begin{itemize}
\item This is how you itemize in LaTeX.
\item I think a good way to learn LaTeX is by starting from this template file and build it up step by step. Often stackoverflow will answer your questions. But here are a few resources:
  \begin{enumerate}
  \item \href{https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes}{Learn LaTeX in 30 minutes}
  \item \href{https://www.latex-project.org/}{LaTeX â€“ A document preparation system}\end{enumerate}
\end{itemize}

\subsubsection{Typesetting Code}

A typical project will involve code. For the example below I took the LaTeX code from \href{https://stackoverflow.com/a/3175141/4600290}{stackoverflow} and the Haskell code from \href{https://hackmd.io/@alexhkurz/HylLKujCP}{my tutorial}.

\begin{lstlisting}
-- run the transition function on a word and a state
run :: (State -> Char -> State) -> State -> [Char] -> State
run delta q [] = q
run delta q (c:cs) = run delta (delta q c) cs 
\end{lstlisting}
%
Short snippets such as \texttt{run :: (State -> Char -> State) -> State -> [Char] -> State} can also be directly fitted into text. There are several ways of doing this, for example, \verb@run :: (State -> Char -> State) -> State -> [Char] -> State@ is slightly different in terms of spaces and linebreaking (and can lead to layout that is better avoided), as is
\begin{verbatim}run :: (State -> Char -> State) -> State -> [Char] -> State\end{verbatim}

\noindent
For more on the topic see \href{https://www.overleaf.com/latex/examples/code-presentations-example-different-ways-shown-in-beamer-metropolis/tsxpnyjbhbds}{Code-Presentations Example}.

\medskip\noindent
Generally speaking,  the methods for displaying code discussed above work well only for short listings of code. For entire programs, it is better to have external links to, for example, Github or \href{https://replit.com/@alexhkurz/automata01#main.hs}{Replit} (click on the "Run" button and/or the ``Code" tab).

\subsubsection{More Mathematics}

We have already seen $x+y=y+x$ as an example of inline maths. We can also typeset mathematics in display mode, for example
$$\frac x y =\frac{xy}{y^2},$$

\noindent
Here is an example of equational reasoning that spans several lines:
\begin{align*}
{\rm fib}(3)
& = {\rm fib}(1) +{\rm fib}(2)  & {\rm fib}(n+2) = {\rm fib}(n)  + {\rm fib}(n+1) \\
& = {\rm fib}(1) +{\rm fib}(0)  + {\rm fib}(1) & {\rm fib}(n+2) = {\rm fib}(n)  + {\rm fib}(n+1) \\
& = 1 + 0  +1 & {\rm fib}(0) = 0,   {\rm fib}(1) = 1\\
& = 2 & {\rm arithmetic}
\end{align*}

\subsubsection{Definitons, Examples, Theorems, Etc}

\begin{definition} 
This is a definition.
\end{definition}

\begin{example}
This is an example.
\end{example}

\begin{proposition}
This is a proposition.
\end{proposition}

\begin{theorem}
This is a theorem.
\end{theorem}

\noindent You can also create your own environment, eg if you want to have Question, Notation, Conjecture, etc.

\subsection{Plagiarism}

To avoid plagiarism, make sure that in addition to \cite{PL} you also cite all the external sources you use. Make sure you cite all your references in your text, not only at the end.

\section{Homework}\label{homework}

This section will contain your solutions to homework. 

\subsection{Week 1}

Homework 1: Using Euclid's Elements Proposition 2 Algorithm on finding the Greatest Common Divisor amongst two numbers.

\subsubsection{Python}
In python, this algorithm can be written as:
\begin{verbatim}
		a = 9
		b = 33

		while(a!=b):
   			if(a>b):
        				a = a-b
    			else:
        				b = b-a
    
		print(a)
\end{verbatim}

Using the sample given, 9 and 33, the Greatest Common Divisor is found in a simple way. Using the Euclid's Elements Proposition 2 Algorithm, we have two variables: \textbf{a} and \textbf{b}. To start, our samples are manually entered from the start of the program, and will begin the while loop. The while loop will continue until the \textbf{a} is the same value as \textbf{b}. The first line of code in the loop is an \textbf{if-statement}. This will compare \textbf{a} and \textbf{b} values, and will continue inside the \textbf{if-statement} if \textbf{a} is a large value than \textbf{b}. The Euclid's Elements Algorithm says: If \[a > b\] then replace \textbf{a} by \[a - b\]This is what happens in this first \textbf{if-statement}, as the variable \textbf{a} is replaced with a - b \medskip\noindent
\medskip\noindent

\noindent If the \textbf{if-statement} is not executed, then the else statement will be preformed. Since our while loop tells us that it will continue until \textbf{a} is the same value as \textbf{b}, then we know that this else statement is: \[b > a\]This is the second part of the Euclid's Elements Proposition 2 Algorithm. It says that when: \[b > a\] to replace \textbf{b} with \[b - a\]This is what happens in this line of python code. The variable \textbf{b} is clearly replaced with b - a. \medskip\noindent

\noindent This while loop will continue until the values of \textbf{a} and \textbf{b} are the same. Once they are, the program will print the value of \textbf{a}. In this particular example, the value \textbf{3} would be printed.

\subsubsection{C++}
In C++, the algorithm can be written as:
\begin{verbatim}
#include <iostream>

using namespace std;

int main(int charc, char** argv){
    int a = 9;
    int b = 33;

    while(a!=b){
        if(a>b){
            a = a-b;
        }
        else{
            b = b-a;
        }
    }
    cout << a << endl;
}
\end{verbatim}
Very similar code to the code in 2.1.1. The same process is being used, with two variables being created before the while loop. The while loop will continue until the values of the two variables are the same. Then the two conditions of \[a > b\] and \[b > a\], are evaluated using an \textbf{if-statement} and \textbf{else-statement}. Once the correct condition is identified, the corresponding calculation done of each variable takes place. This will continue until the Greatest Common Divisor is found, and is printed to the screen. In this place, 3 is again printed.

\subsection{Week 2}

Homework 2: Create six Functions using Haskell: Select Evens, Select Odds, Member, Append, Revert, and Less Equal.

\subsubsection{Select Evens and Select Odds}

The task of these two functions could be used with each other. For Select Evens, the user would write the function name, then a list. The output would be the even element indices (Starting with 1 not 0). Here is the code for both.

\begin{verbatim}

select_evens [] = []
select_evens (x:xs) = select_odds xs

select_odds (x:xs) = x : select_evens xs
select_odds [] = []
\end{verbatim}

\noindent These two functions are connected. Without one, the other will not work.
\newline
\newline Going through the program, we will start with Select Odds. Using recursion, the head element will be split off first. Select Evens will be called with the other elements left in the list. Select Evens will then split the head and other elements again. This process will continue until the tail is an empty list. These methods will allow for only the odd indexed elements to be printed, or only the even indexed elements. 
\newline
\newline Here are a few outputs from the terminal:
\begin{verbatim}
ghci> select_evens ["a","b","c","d","e"]
["b","d"]
ghci> select_odds ["a","b","c"]
["a","c"]
ghci> select_odds ["a","b","c","d","e"]
["a","c","e"]
ghci> select_odds [1,2,3,4,5]
[1,3,5]
ghci> select_evens[432,34,543,2334,23]
[34,2334]
\end{verbatim}
\noindent\newline\newline Here is the Task 2 Equational Reasoning for the Select Evens and Odds Function:

\begin{verbatim}
select_evens ["a","b","c","d","e"] = 

select_evens ("a" : ["b","c","d","e"]]) = select_odds ["b","c","d","e"]

select_odds ("b" : ["c","d","e"]) = "b" : select_evens["c", "d", "e"]

select_evens ("c" : ["d", "e"]) = select_odds["d", "e"]

select_odds ("d" : ["e"]) = "b" : ("d" : select_evens ["e"])

select_evens ("e" : []) = select_odds []

select_odds [] =  "b" : ("d" : ([]))

["b", "d"]
\end{verbatim}

\noindent\newline Note that if Select Odds was called, the same procedure would occur, but would start with Select Odds first and would be the opposite of this output.
\subsubsection{Member}
In the member function, the user would ask for a "True" or "False" about if a list consisted of a particular element. If the list consisted of the element, then True would be returned. Otherwise, False is returned.

\begin{verbatim}
member y (x:xs) = if y==x
    then True
    else if len(xs) < 1
        then False
        else member y xs
\end{verbatim}
The element that the user wants to know is the y. It starts off by comparing y to x, which is the head of the current list. If y is the same as x, then the element that the user is looking for is indeed in the list and True is returned. However, if it is not, then we will use the len function to see the size of the rest of the list. If it is not above 1, then False is returned. False is returned because there is nothing left to compare to the user element. However if it is above 1, then member is called again with the user element and the rest of the elements. This simulates the element being compared to each element in the list. \newline
\newline Here are some outputs for this function:
\begin{verbatim}
ghci> member "a" ["a", "b"]
True
ghci> member "a" ["c", "d", "e"]
False
ghci> member 4 [2,3,5]
False
ghci> member 4 [2,3,3,4,5]
True
ghci> member 4 [4,1,6,2]
True
\end{verbatim}
\noindent\newline\newline Here is the Task 2 Equational Reasoning for the Member Function:
\begin{verbatim}
member 4 [2,3,4] =
    4 == 2
    else if len([3,4]) < 1

    len[3,4] = 3

    else if 3 < 1
        then False
        else member 4 [3,4]
    
member 4 [3,4]  
    4 == 3
    else if len([4]) < 1

    len[4] = 2

    else if 2 < 1
        then False
        else member 4 [4]
    
member 4 [4]
    4 == 4
    then True
\end{verbatim}

\subsubsection{Append}
The append function takes two lists from the user, and appends all of the second lists elements to the back of the first list. This function was difficult for me at first, but I realized that the first list stays at the front of the list, and that only the second list needed elements to "move". \newline
\newline Below is my code for the Append Function:
\begin{verbatim}
append [] (y:ys) = if len(ys) > 0
    then 
        y : append [] ys
    else
        [y] 
append (x:xs) (y:ys) = x : append xs (y:ys)
\end{verbatim}
The last line will be the first line that executes. The user will have the two lists, but the function will have to iterate the entire (x:xs) list first. This is because these elements will be in the front of the new list regardless. After this line is recursively called, the first line will be called with an empty list and all of the second list. The len function is also used in this function as well. The if statement looks at the size of the tail elements of the second list. If it is greater than 0, then it will recursively add the elements to the list that already contains the first list elements. Once the len(ys) is not greater than 0, the else statement will have [y] which will basically not recall any of the append functions, and will not append anything to the list. This will let the recursion end. \newline\newline

 \noindent Here are some outputs of the append function:\newline
\begin{verbatim}
ghci> append [1,2] [3,4,5]
[1,2,3,4,5]
ghci> append [1,2,3,4,5] [7,8,9]
[1,2,3,4,5,7,8,9]
\end{verbatim}

\noindent\newline\newline Here is the Task 2 Equational Reasoning for the Append Function:
\begin{verbatim}
append [1,2,3] [7,8,9] =
    1 : (append [2,3] [7,8,9])
    1 : (2 : (append [3] [7,8,9]))
    1 : (2 : (3 : (append [] [7,8,9])))
    1 : (2 : (3 : (7 : (append [8,9]))))
    1 : (2 : (3 : (7 : (8 : (append [9])))))
    1 : (2 : (3 : (7 : (8 : (9 : (append[]))))))
    1 : (2 : (3 : (7 : (8 : (9 : []))))
\end{verbatim}

\subsubsection{Revert}
The Revert function will take a list from the user, and output the list with the elements in reversed order. \newline
\newline Below is the code to the Revert Function:
\begin{verbatim}
revert [] = []
revert (x:xs) = append (revert xs) [x]
\end{verbatim}
This function uses the previously created function Append. Revert will call the append method recursively. It will append the first element of the list to the back, then continue with the rest of the elements. This was designed with some thought of a Stack. 
\newline Here are some outputs for the Revert Function:
\begin{verbatim}
ghci> revert [1,2,3]
[3,2,1]
ghci> revert [8,1,2,4]
[4,2,1,8]
\end{verbatim}

\noindent\newline\newline Here is the Task 2 Equational Reasoning for the Revert Function:
\begin{verbatim}
revert [1,2,3] = 
    append (revert [2,3]) [1]
    append (append (revert([3]) [2])) [1]
    append (append (append (revert []) [3]) [2]) [1]
    append (append (append [] [3]) [2]) [1]
    append (append [3] [2]) [1]
    append [3,2] [1]
    [3,2,1]
\end{verbatim}

\subsubsection{Less Equal}
The last function that I created was Less Equal. This simply compared the elements from two lists to see if first list was less than or equal to the same indexed element of the other list. For example [1,2] vs [5,6] would be true because 1 is less than or equal to 5 and 2 is less than or equal to 6.\newline
\newline Below is the code to the Less equal Function
\begin{verbatim}
less_equal [] [] = True
less_equal (x:xs) (y:ys) = if x<=y
    then 
        less_equal xs ys
    else
        False
\end{verbatim}
The beginning of this function will start with the second line. If compares the head elements of list 1 and list 2. If x is less than or equal to, the Less Equal function will be called again, but this time with the tail elements. If at any point the list 1 element "x" is greater than list 2 element "y", False will be returned. If all of the elements are compared, then base case is called. This is because there are no elements left, so they are empty lists. Since nothing was flagged, then True will be returned, meaning that all of the list 1 elements are either less than or equal to the list 2 elements at the same index.\newline
\newline Here are some outputs for the Less Equal Function:
\begin{verbatim}
ghci> less_equal [1,2,3] [2,3,4]
True
ghci> less_equal [1,2,3] [2,3,2]
False
ghci> less_equal [1,2,3] [2,3,3]
True
\end{verbatim}
\noindent\newline\newline Here is the Task 2 Equational Reasoning for the Less Equal Function:
\begin{verbatim}
less_equal [1,2,3] [2,3,4] =
    1 <= 2
    then
        less_equal [2,3] [3,4]

    2 <= 3
    then
        less_equal [3] [4]
    
    3 <= 4
    then
        less_equal [] []
    
    True
\end{verbatim}
\noindent\newline If the left value was ever larger, than False would be the value.
\subsubsection{Len}
I did not create this function. I took this from \href{https://hackmd.io/@alexhkurz/H1jUka4Gv#fn2}{Hackmd.io}, thanks to Professor Kurz. Below is the code used that my other functions also used.
\begin{verbatim}
len [] = 0
len (x:xs) = 1 + len xs
\end{verbatim}

\subsection{Week 3}
Week 3 Homework was about the Hanoi Tower. The task was to complete the execution from the dots down. Here that is:
\begin{verbatim}
hanoi 5 0 2  
	hanoi 4 0 1 
		hanoi 3 0 2
			hanoi 2 0 1 
				hanoi 1 0 2 = move 0 2 
				move  0 1
				hanoi 1 2 1 = move 2 1 
			move 0 2  
			hanoi 2 1 2  
				hanoi 1 1 0 = move 1 0  
				move  1 2  
				hanoi 1 0 2 = move 0 2
        move 0 1
        hanoi 3 2 1
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
            move 2 1
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
    move 0 2
    hanoi 4 1 2
        hanoi 3 1 0
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
            move 1 0
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
        move 1 2
        hanoi 3 0 2
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
            move 0 2 
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
\end{verbatim}
I followed this exact sequence with the \href{https://www.mathsisfun.com/games/towerofhanoi.html}{Tower of Hanoi} website. It took 31 turns, which is the minimum moves possible for a Hanoi Tower of size 5. \newline

\noindent The word "Hanoi" appears 31 times. The word "move" also appears 31 times. \newline
\noindent A simple equation can be expressed for the number of blocks in the Hanoi Tower. Assuming n is the number of blocks/rings in the tower, the minimum number of moves can be expressed as $$2^n - 1$$ In this case, n was 5. Thus, $$2^5 = 32$$ and then $$32 - 1 = 31$$ Here are some other minimum moves required for other ring heights. $$2^1 - 1 = 1$$ $$2^2 - 1 = 3$$ $$2^3 - 1 = 7$$ $$2^4 - 1 = 15$$ $$2^6 - 1 = 63$$
\section{Project}

Introductory remarks ...

The following structure should be suitable for most practical projects. 

\subsection{Specification}
\subsection{Prototype}
\subsection{Documentation}
\subsection{Critical Appraisal}

\ldots

\section{Conclusions}\label{conclusions}

(approx 400 words)

In the conclusion, I want a critical reflection on the content of the course. Step back from the technical details. How does the course fit into the wider world of programming languages and software engineering?

\begin{thebibliography}{99}
\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/README.md}{Programming Languages 2022}, Chapman University, 2022.\newline
\newline
\href{https://hackmd.io/@alexhkurz/H1jUka4Gv#fn2}{Hackmd.io} Professor Kurz, Chapman University 2022\newline\newline
\href{https://www.mathsisfun.com/games/towerofhanoi.html}{Tower of Hanoi}\newline
\end{thebibliography}

\end{document}